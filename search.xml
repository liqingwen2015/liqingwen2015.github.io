<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>05 Docker 引擎</title>
    <url>/2020/01/11/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%20Docker/05%20Docker%20%E5%BC%95%E6%93%8E/</url>
    <content><![CDATA[<h1>5.1 Docker 引擎 – 简介</h1>
<p>Docker 引擎是用来运行和管理容器的核心组件。通常人们会简单地将其代指为 Docker 或 Docker 平台。</p>
<p>基于开放容器计划（OCI）标准，Docker 引擎采用了模块化的设计原则，其组件是可替换的。</p>
<p>Docker 引擎就像汽车引擎 – 二者都是模块化的，并且由许多可交换的部件组成。</p>
<a id="more"></a>
<p>Docker 引擎主要组件构成：</p>
<ul>
<li>
<p>Docker 客户端（Docker Client）</p>
</li>
<li>
<p>Docker 守护进程（Docker daemon）</p>
</li>
<li>
<p>containerd</p>
</li>
<li>
<p>runc</p>
</li>
</ul>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/4-1Z416140U0537.gif" alt="Docker总体逻辑"></p>
<h1>5.2 Docker 引擎 – 详解</h1>
<p>Docker 引擎核心组件：</p>
<ul>
<li>LXC</li>
<li>Docker daemon</li>
</ul>
<p>Docker daemon 是单一的二进制文件，包含 Docker 客户端、Docker API、容器运行时、镜像构建等。</p>
<p>LXC 提供了对命名空间（Namespace）和控制组（CGroup）等基础工具的操作能力，它们是基于 Linux 内核的容器虚拟化技术。</p>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/4-1Z416140926303.gif" alt="先前的Docker架构"></p>
<h2 id="5-2-1-摆脱-LXC">5.2.1 摆脱 LXC</h2>
<p>LXC 的问题？</p>
<ul>
<li>基于 Linux，无法跨平台</li>
<li>它属于核心组件，如果依赖于外部工具，会给项目带来巨大风险</li>
</ul>
<p>后来，使用自研工具 Libcontainer 替代 LXC。</p>
<h2 id="5-2-2-摒弃大而全的-Docker-daemon">5.2.2 摒弃大而全的 Docker daemon</h2>
<p>Docker daemon 的整体性所带来的问题：</p>
<ul>
<li>难于变更</li>
<li>运行越来越慢</li>
</ul>
<p>解决方案：</p>
<p>拆解进程，从而将其模块化。这项任务的目标是尽可能拆解出其中的功能特性，并用小而专的工具来实现。</p>
<p>UNIX 的软件哲学：小而专的工具可以组装为大型工具。</p>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/4-1Z41614102M63.gif" alt="Docker引擎的架构"></p>
<h1>5.2.3 开放容器计划（OCI）的影响</h1>
<p>OCI 定义的规范（标准）：</p>
<ul>
<li>镜像规范</li>
<li>容器运行时规范</li>
</ul>
<p>于 2017 年 7 月发布了 1.0 版。</p>
<h2 id="5-2-4-runc">5.2.4 runc</h2>
<p>runc 是 OCI 容器运行时规范的参考实现。</p>
<p>runc 实质上是一个轻量级的、针对 Libcontainer 进行了包装的命令行交互工具。</p>
<p>runc 的作用：创建容器</p>
<ul>
<li>它是一个 CLI 包装器</li>
<li>它是一个独立的容器运行时工具</li>
</ul>
<p>runc 所在的那一层称为“OCI 层”。</p>
<h2 id="5-2-5-containerd">5.2.5 containerd</h2>
<p>主要包含容器的执行逻辑，主要任务是容器的生命周期管理。</p>
<h2 id="5-2-6-启动一个新的容器（示例）">5.2.6 启动一个新的容器（示例）</h2>
<p>启动一个新容器</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker container run --name ctrl -it alpine:latest sh</span><br></pre></td></tr></table></figure>
<p>在使用 Docker 命令行工具执行上述命令时，Docker 客户端会将其转换为合适的 API 格式，并发送到正确的 API 端点。</p>
<p>API 是在 daemon 中实现的。</p>
<p>一旦 daemon 接收到创建新容器的命令，就后悔向 containerd 发出调用命令。</p>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/4-1Z4161413112O.gif" alt="启动新容器的过程"></p>
<h2 id="5-2-7-该模型的显著优势">5.2.7 该模型的显著优势</h2>
<p>将所有的用于启动、管理容器的逻辑和代码从 daemon 中移除，意味着容器运行时与 Docker daemon 是解耦的。对 Docker daemon 的维护和升级工作不会影响到运行中的容器。</p>
<p>在旧模型中，所有容器运行时的逻辑都在 daemon 中实现，启动和停止 daemon 会导致宿主机上所有运行中的容器被杀掉。这在生产环境中是一个大问题。</p>
<h2 id="5-2-8-shim">5.2.8 shim</h2>
<p>部分职责：</p>
<ul>
<li>保持所有 STDIN 和 STDOUT 流是开启状态，从而当 daemon 重启时，容器不会因为管道（pipe）的关闭而终止</li>
<li>将容器的退出状态反馈给 daemon</li>
</ul>
<h2 id="5-2-9-daemon-的作用">5.2.9 daemon 的作用</h2>
<p>当前，daemon 的主要功能包括镜像管理、镜像构建、REST API、身份验证、安全、核心网络以及编排。</p>
<h1>5.3 本章小结</h1>
<p>基于 OCI 的标准，Docker 引擎目前采用模块化设计。</p>
<p>Docker daemon 实现了 Docker API，基于 HTTP。</p>
<p>对容器的操作由 containerd 完成。</p>
<p>containerd 需要指挥与 OCI 兼容的容器运行时来创建容器。</p>
<p>runc 可以作为独立的 CLI 工具来创建容器。</p>
<p>目前仍然有许多的功能是在 Docker daemon 中实现。多数功能接下来会一步步进行拆解，进行模块化。</p>
<h1>参考</h1>
]]></content>
      <categories>
        <category>《深入浅出 Docker》</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>微服务</tag>
      </tags>
  </entry>
  <entry>
    <title>01 HTTP 协议和 Fiddle 抓包</title>
    <url>/2020/01/09/HTTP%20%E6%8A%93%E5%8C%85%E5%AE%9E%E6%88%98/01%20HTTP%20%E5%8D%8F%E8%AE%AE%E5%92%8C%20Fiddle%20%E6%8A%93%E5%8C%85/</url>
    <content><![CDATA[<p>Web 浏览器和 Web 服务器之间是通过 HTTP 协议相互通信的。</p>
<a id="more"></a>
<h1>1.1 HTTP 协议介绍</h1>
<h2 id="1-1-1-什么是-HTTP-协议">1.1.1 什么是 HTTP 协议</h2>
<p>协议是指计算机通信网络中两台计算机之间进行通信所必须共同遵守的规定或规则 。</p>
<p>超文本传输协议（ HyperText Transfer Protocol, HTTP ）是互联网上应用最广泛的一种网络协议，它允许将超文本标记语 言（ HTML ）文档从 Web 服务器传送到客户端的浏览器。</p>
<p>目前我们使用的 HTTP 协议是 HTTP/1.1 版本 。</p>
<h2 id="1-1-2-如何学习-HTTP-协议">1.1.2 如何学习 HTTP 协议</h2>
<p>必须先了解 HTTP 协议的基本知识；然后找一个抓包软件实实在在地看到数据包的内容，并且看到数据包是如何在浏览器和 Web 服务器中进行交互的。</p>
<p>Fiddler 就是我们需要的抓包工具 。</p>
<h2 id="1-1-3-HTTP-协议的工作原理">1.1.3 HTTP 协议的工作原理</h2>
<p>我们打开浏览器，在地址栏中输入 URL ，然后我们就看到了网页。原理是怎样的呢？</p>
<p>实际上，我们输入 URL 后，浏览器就给 Web 服务器发送了一个 HTTP 请求（HTTP Request）,Web 服务器接到 HTTP 请求后进行处理，生成相应的 HTTP 响应（ HTTP Response），然后发送给浏览器 。浏览器解析 HTTP 响应中的 HTML，这样我们就看到了网页 。</p>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210102132216079.png" alt="image-20210102132216079"></p>
<p>浏览器客户端和 Web 服务器之间是通过 HTTP 协议来交流的。 目前主流的 Web 浏览器有微软的 IE、Firefox 和 Chrome 。</p>
<p>Web 浏览器会给 Web 服务器发送一条 HTTP 请求 ， 服务器会把 Web 对象发送给浏览器，浏览器解析 Web 对象，这些对象就显示在屏幕上了 。</p>
<h1>1.2 Fiddler 的介绍</h1>
<p>Fiddler 是世界上最强大最好用的 Web 调试工具，能记录所有客户端和服务器 的 HTTP 和 HTTPS 请求，允许你监视、设置断点，甚至修改输入输出数据 。</p>
<p>Fiddler 包含了一个强大的基于事件脚本 的子系统，并且能使用 .NET 语言进行扩展。</p>
<p>Fiddler 是用 C# 开发的 ，作者是 Eric Lawrence。</p>
<h2 id="1-2-1-Fiddler-的下载和安装">1.2.1 Fiddler 的下载和安装</h2>
<p>Fiddler 的官方网站是 <a href="http://www.fiddler2.com">www.fiddler2.com</a>，下载地址是 <a href="http://www.getfiddler.com">http://www.getfiddler.com</a>。</p>
<p>Fiddler 有 2 个版本，F iddler2 和 Fiddler4 ，两者功能相同。建议使用 Fiddler4 。</p>
<h2 id="1-2-2-Fiddler-的基本界面">1.2.2 Fiddler 的基本界面</h2>
<p>Fiddler 基本界面包括如下区域：</p>
<ol>
<li>主菜单栏：菜单 中几乎可以启 动所有的 Fiddler 功能</li>
<li>工具栏 ：提供了很多常见的命令</li>
<li>Web Sessions 列表（会话列表）：显示捕捉到的每个 Session 的简短信息。平常都需要在这里选择一个或者多个 Ses sion 后再进行操作</li>
<li>功能面板：这里有很多选项卡 ，提供了 很多功能。我们 常用的是 Inspectors 选项卡</li>
<li>QuickExec：命令行工具，可以输入简单的命令， 例如输入 cls 可以清空 Web Sessions</li>
<li>状态栏：上面显示 了 Fiddler 的一些配置信 息</li>
</ol>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210102140149408.png" alt="image-20210102140149408"></p>
<h2 id="1-2-3-Inspectors-选项卡">1.2.3 Inspectors 选项卡</h2>
<p>Inspectors 选项卡下可以查看 HTTP 请求和 HTTP 响应的报文结构 。其中 Raw 选项卡可以查看完整的消息，Headers 选项卡只查看消息中的 Header 。</p>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210102140202018.png" alt="image-20210102140202018"></p>
<h2 id="1-2-4-Web-Sessions-列表">1.2.4 Web Sessions 列表</h2>
<p>Fiddler 窗口的左边是 Web Sessions 列表，是 Fiddler 中 最重要的部分 ，显示了每个 Session 的摘要信息。Fiddler 中的大部分操作都需要在 Web Sessions 列表中选择一个或者多个 Session，再进行其他操作。Web Sessions 列表中的表头可以排序。</p>
<p>一个 Session 包含了 一个 HTTP 请求和一个 HTTP 响应。</p>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210102140350590.png" alt="image-20210102140350590"></p>
<p>Web Sessions 列表栏中包含的信息如下：</p>
<ol>
<li>＃：这是 Fiddler 生成的 ID（最好是按顺序排列〉。</li>
<li>Result：响应的状态码。</li>
<li>Protocol ：使用的协议 HTTP 或者 HTTPS</li>
<li>Host：服务器的主机名和端口号</li>
<li>URL: URL 的路径</li>
<li>Body: HTTP 响应中包含的字节数</li>
<li>Caching：跟缓存相关的字段的值</li>
<li>Content-Type：响应中 Content-Type 的值</li>
<li>Process：对应本地 Windows 的进程</li>
</ol>
<h2 id="1-2-5-Fiddler-捕获-HTTP-协议的数据包">1.2.5 Fiddler 捕获 HTTP 协议的数据包</h2>
<ol>
<li>启动 Fiddler，打开任何一个浏览器，输入 <a href="http://www.cnblogs.com/tankxiao/">http://www.cnblogs.com/tankxiao/</a></li>
<li>选择任何一个 Session，然后选择 Inspectors 选项卡，就可以查看详细内容</li>
</ol>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210102140727667.png" alt="image-20210102140727667"></p>
<h2 id="1-2-6-Fiddler-设置开始捕获和停止捕获">1.2.6 Fiddler 设置开始捕获和停止捕获</h2>
<p>我们把捕获 HTTP 数据包的过程简称为抓包 。 在 Fiddler 的使用过程中 ， 当我们已经抓到自己想要的数据包后，可以停止抓包，以避免抓到一些不需要的数据包。接下来介绍两种设置方法。</p>
<p>方法一：在 Fiddler 中单击 File -&gt; Capture Traffic（快捷键是 Fl2） 来开始抓包或者停止抓包 。</p>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210102141010155.png" alt="image-20210102141010155"></p>
<p>方法二：单击 Fiddler 左下角的“ Capturing ＂按钮来开始抓包或者停止抓包。</p>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210102141039374.png" alt="image-20210102141039374"></p>
<h1>1.3 HTTP 协议报文的结构</h1>
<p>HTTP 报文分 2 个：一个是 HTTP 请求报文，一个是 HTTP 响应报文。</p>
<h2 id="1-3-1-HTTP-请求报文的结构">1.3.1 HTTP 请求报文的结构</h2>
<p>浏览器发送给 Web 服务器的 HTTP 请求报文内容。</p>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210102141211762.png" alt="image-20210102141211762"></p>
<p>HTTP 请求报文的详细内容：</p>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210102141238392.png" alt="image-20210102141238392"></p>
<p>HTTP 请求报文分为 3 部分 ：第一部分 叫 起始行（ Request line ），第二部分叫首部（Request Header），第三部分叫主体（Body）</p>
<ol>
<li>第一行中的 Method 表示请求方法，比如“ POST ”或者“ GET ”，现在使用的 HTTP 协议版本是 HTTP/ 1.1</li>
<li>第二部分是首部（Header），后面会详细介绍这些首部的用法</li>
<li>第三部分是主体（Body）</li>
</ol>
<p>【注意】Header 首部和 Body（主体）之间有一个空行</p>
<h2 id="1-3-2-HTTP-响应报文的结构">1.3.2 HTTP 响应报文的结构</h2>
<p>Web 服务器发送给浏览器的 HTTP 响应报文内容：</p>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210102142354842.png" alt="image-20210102142354842"></p>
<p>HTTP 响应报文的详细内容：</p>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210102142427966.png" alt="image-20210102142427966"></p>
<p>Response 消息的结构和 Request 消息 的 结构基本一样 ，同样也分为 3 部分：第一部分 叫响 应行（ Response Line ） ， 第 二部分 叫响 应首部（Response Header），第三部分是主体（Body） 。</p>
<ol>
<li>第一部分是起始行，有状态码和状态码消息</li>
<li>第二部分是首部（ Header ），后面会详细介绍这些首部的用法</li>
<li>第三部分是主体（ Body ），如果是 GET 方法，就没有主体</li>
</ol>
<p>【注意】Header 首部和 Body（主体）之间有一个空行</p>
<h2 id="1-3-3-Fiddler-捕获博客主页，查看-HTTP-请求和-HTTP-响应报文">1.3.3 Fiddler 捕获博客主页，查看 HTTP 请求和 HTTP 响应报文</h2>
<ol>
<li>启动 Fiddler，打开浏览器 ，输入  <a href="http://www.cnblogs.com/tankxiao">http://www.cnblogs.com/tankxiao</a></li>
<li>在 Fiddler 的界面中找到 <a href="http://www.cnblogs.com/tankxiao%EF%BC%8C%E7%84%B6%E5%90%8E%E9%80%89%E6%8B%A9">www.cnblogs.com/tankxiao，然后选择</a> Inspectors 选项卡</li>
</ol>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210102142832413.png" alt="image-20210102142832413"></p>
<ol start="3">
<li>在 HTTP 请求中选择 Raw 选项卡 ，这样就能看到完整的 HTTP 请求报文。由于这是个 GET 方法，所以 HTTP 请求没有 Body</li>
<li>在 HTTP 响应中选择 Raw 选项卡，这样就能看到完整的 HTTP 响应报文。</li>
</ol>
<h1>1.4 Fiddler 抓包的原理</h1>
<p>Fiddler 为什么能抓包呢？Fiddler 本质上是一个 Web 代理服务器。它的默认工作端口是 8888。</p>
<p>我们可以查看 Fiddler 的工作端口。启动 Fiddler，如图所示，在菜单栏中单击 Tools -&gt; Fiddler options。</p>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210102143045024.png" alt="image-20210102143045024"></p>
<h2 id="1-4-1-什么是代理服务器">1.4.1 什么是代理服务器</h2>
<p>Web 代理（ Proxy Server）服务器是网络的中间实体。代理位于 Web 客户端和 Web 服务器之间，扮演“中间人”的角色。</p>
<p>HTTP 的代理服务器既是 Web 服务器又是 Web 客户端。</p>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210102143138810.png" alt="image-20210102143138810"></p>
<p>代理服务器是网络信息的中转站，它具有以下功能：</p>
<ol>
<li>共享网络。能解决仅仅有一条线路 、 一个公有 IP 的问题。在公有 IP 资源严重不足的情况下，可以满足局域网大量用户同时共享上网的需求</li>
<li>提高了访问速度。因为大部分的代理服务器都有缓冲功能，可以直接读取，无须再连接到远程 Web 服务器。这样可以达到加快访问网站的速度、节约通信带宽的目的</li>
<li>突破了访问限制 。当访问权限受到限制时，可以使用有权限的代理服务器</li>
<li>隐藏身份。内部网的用户要对外发布信息，就需要使用代理服务器的反向代理功能 。 这样就不会影响内部网络的安全性能，起到隐藏身份的目的</li>
</ol>
<h2 id="1-4-2-Fiddler-的工作原理">1.4.2 Fiddler 的工作原理</h2>
<p>Fiddler 是以代理 Web 服务器的形式工作的，它使用代理地址：127.0.0.1，端口：8888。</p>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210102143440502.png" alt="image-20210102143440502"></p>
<p>Fiddler 启动的时候，会偷偷地把 Internet 选项中的代理修改为 127.0.0.1 ，端口：8888 。<br>
当 F iddler 退出的时候，它会自动在 Internet 选项中取消代理，这样就不会影响别的程序 。<br>
如果 Fiddler 非正常退出，这时候因为 Fiddler 没有自动注销，会造成网页无法访问 。解决的办法是重新启动 Fiddler 。</p>
<h2 id="1-4-3-查看-Internet-选项代理设置">1.4.3 查看 Internet 选项代理设置</h2>
<p>先启动 Fiddler，打开控制面板，找到 Internet 属性，然后选择连接 -&gt; 局域网设置 -&gt; 高级，可以看到代理服务器地址己经被 Fiddler 设置为 127.0.0.1 :8888 了。</p>
<p>关闭 Fiddler，可以看到代理服务器地址已经取消了。</p>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210102143636337.png" alt="image-20210102143636337"></p>
<h2 id="1-4-4-Fiddler-如何捕获-Firefox">1.4.4 Fiddler 如何捕获 Firefox</h2>
<p>有时候我们会发现 ，Fiddler 能捕获 IE 和其他浏览器发出的请求，但是不能捕获 Firefox 发出的请求。<br>
之所以不能捕获 Firefox 的请求，那是因为 Firefox 的代理服务器没有配置成 Fiddler 。<br>
打开 Firefox，在菜单栏中选择工具 -&gt; 选项，-&gt; 高级，-&gt; 网络 -&gt; 设置。选择使用系统代理设置。</p>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210102143808756.png" alt="image-20210102143808756"></p>
<p>或者手动配置，指向 Fiddler。</p>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210102143833608.png" alt="image-20210102143833608"></p>
<h2 id="1-4-5-Fiddler-能捕获哪些设备的-HTTP-数据包">1.4.5 Fiddler 能捕获哪些设备的 HTTP 数据包</h2>
<p>任何支持代理的 HTTP 请求都能被 Fiddler 捕获到，首先 Fiddler 能捕获各种浏览器，比如 IE、Firefox，Chrome 发出来的数据包 。</p>
<p>Fiddler 还能捕获各种移动设备，比如 Android 手机、苹果手机、iPad 等发出的数据包。</p>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210102143942796.png" alt="image-20210102143942796"></p>
<p>Fiddler 能捕获任何程序发出来的 HTTP/HTTPS 请求，只要这个程序支持 Web 代理服务器即可。</p>
<p>比如 Fiddler 能抓到 QQ 发出的包 ，当然 QQ 中发的聊天消息是抓不到的，因为 QQ 中的聊天信息使用的是 OICQ 协议，不是 HTTP 协议 。</p>
<p>只要在 QQ 中设置代理服务器即可实现抓包。</p>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210102144033672.png" alt="image-20210102144033672"></p>
<h2 id="1-4-6-解压-HTTP-响应">1.4.6 解压 HTTP 响应</h2>
<p>在 Fiddler 抓包的过程中，我们经常看到 HTTP 响应是乱码，单击“ Response body is encoded. Click to decode. ＂按钮可以解压 HTTP 响应 。</p>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210102144112014.png" alt="image-20210102144112014"></p>
<ul>
<li>
<h1>参考</h1>
<ul>
<li></li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>《HTTP 抓包实战》</category>
      </categories>
      <tags>
        <tag>http</tag>
        <tag>抓包</tag>
      </tags>
  </entry>
  <entry>
    <title>02 HTTPS 协议和 Fiddler 抓包</title>
    <url>/2020/01/09/HTTP%20%E6%8A%93%E5%8C%85%E5%AE%9E%E6%88%98/02%20HTTPS%20%E5%8D%8F%E8%AE%AE%E5%92%8C%20Fiddler%20%E6%8A%93%E5%8C%85/</url>
    <content><![CDATA[<p>Fiddler 默认情况下只会捕获 HTTP ，需要设置后才能捕获 HTTPS。</p>
<a id="more"></a>
<h1>2.1 HTTP 协议是不安全的</h1>
<p>浏览器发送给服务器的内 容非常容易被中 间人拦截到。</p>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210102155440057.png" alt="image-20210102155440057"></p>
<p>如果浏览器发送一些敏感的数据，比如账号、密码、信用卡账户、银行账户给服务器，是非常危险的。</p>
<h1>2.2 Web 通信如何做到安全</h1>
<p>什么是安全？</p>
<ol>
<li>浏览器和 Web 服务器之间的内容应该只有浏览器和 Web 服务器能看到通信的真正内容</li>
<li>HTTP 请求的内容和 HTTP 请求的响应不会被第三方篡改</li>
</ol>
<p>我们马上就能想到各种加密算法，如非对称加密、对称加密、DES 、 RSA 等 。 对称加密是密钥同时扮演加密和解密 的角色 。只要这个密钥不公开给第<br>
三者，同时密钥足够安全，我们就能确保安全问题。</p>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210102155733718.png" alt="image-20210102155733718"></p>
<p>只有浏览器和 Web 服务器知道如何加密和解密它们之间的消息。</p>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210102155815582.png" alt="image-20210102155815582"></p>
<p>Web 服务器与每个客户端使用不同的对称加密算法。</p>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210102155950837.png" alt="image-20210102155950837"></p>
<h1>2.3 什么是 HTTPS</h1>
<p>HTTPS 就是加过密的 HTTP 。使用 HTTPS 后，浏览器客户端和 Web 服务器传输的数据是加密的，只有浏览器和服务器端知道内容。</p>
<p>HTTPS = HTTP+TLS 或者 SSL。采用 HTTPS 的网站需要去数字证书认证机构（Certificate Authority, CA）申请证书。</p>
<p>通过这个证书，浏览器在请求数据前与 Web 服务器有几次握手验证，以证明相互的身份，然后对 HTTP 请求和响应进行加密。</p>
<h1>2.4 Fiddler 如何捕获 HTTPS 会话</h1>
<p>默认情况下，Fiddler 不会捕获 HTTP 会话，需要进行设置：启动 Fiddler，在菜单栏中单击 Tool -&gt; Fiddler Options -&gt; HTTPS，选中“Decrypt HTPS traffic”，同时选中“ Ignore server certificate errors”来忽略一些证书错误。</p>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210102160405568.png" alt="image-20210102160405568"></p>
<p>Fiddler 会弹出 警告信息，单击“ Yes ”，信任证书。</p>
<p>系统弹出警告框，单击“ Yes”安装证书。</p>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210102160500262.png" alt="image-20210102160500262"></p>
<p>安装证书后，测试一下 Fiddler 能否捕捉 HTTPS 请求 。 打开 IE 浏览器，输入 <a href="https://www.baidu.com">https://www.baidu.com</a> ，在 Fiddler 中查看是否捕捉到了 HTTPS 的 百度请求。</p>
<h2 id="2-4-1-添加例外绕过-HTTPS-证件错误">2.4.1 添加例外绕过 HTTPS 证件错误</h2>
<p>虽然按照上面的操作，在 PC 上安装好了 Fiddler 的证书，但有时候，当使用 Fiddler，捕获 HTTPS 网站的时候，仍会出现连接错误 。</p>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210102160700808.png" alt="image-20210102160700808"></p>
<p>单击“我己充分了解可能的风险 －＞ 添加例外－＞确认安全例外”，可以绕过证书错误。</p>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210102160740933.png" alt="image-20210102160740933"></p>
<h2 id="2-4-2-Firefox-中安装证书">2.4.2 Firefox 中安装证书</h2>
<p>包括 IE 、 Chrome 和 Safari 在内的大部分应用都使用 Windows 证书库来验证证书。Firefox 浏览器是自己维护证书列表，所以需要单独安装 Fiddler 证书 。</p>
<p>单独给 Firefox 安装证书：</p>
<ol>
<li>单击 Fiddler Options 窗口的 HTTPS 选项卡 Actions 下面的 ”Export Root Certificate to Desktop“ 按钮，把证书导出到桌面。Fiddler 证书的文件名叫作 “FiddlerRoot.cer“</li>
</ol>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210102160955872.png" alt="image-20210102160955872"></p>
<ol start="2">
<li>打开 Firefox，在菜单栏中选择工具 -&gt; 选项 -&gt; 高级 -&gt; 证书</li>
<li>单击“查看证书”，打开证书管理器</li>
<li>在证书管理器界面中选择“证书机构飞单击导入，选择“ FiddlerRoot.cer”</li>
<li>在弹出的对话框中选中 3 个多选框。</li>
</ol>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210102161137499.png" alt="image-20210102161137499"></p>
<p>安装证书后，Fiddler 就能捕获 Firefox 发出的 HTTPS 请求了 。</p>
<h2 id="2-4-3-Fiddler-可以捕获-HTTPS-的握手验证请求">2.4.3 Fiddler 可以捕获 HTTPS 的握手验证请求</h2>
<p>当浏览器访问 HTTPS 网页的时候，Fiddler 能捕获到很多握手验证的请求，比如用浏览器打开 <a href="https://www.baidu.com">https://www.baidu.com</a>，在 Fiddler 中就能抓到很多“ Tunnel to”的请求。</p>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210102161328341.png" alt="image-20210102161328341"></p>
<p>HTTP Tunnel （ 也叫 HTTP 隧道 、HTTP 穿梭）是这样一种技术 ：它用 HTTP 协议在要通信的 Client 和 Server 建立起一条 “ Tunnel“，然后 Client 和 Server<br>
之间的通信都是在这条 Tunnel 的基础之上实现的。</p>
<p>简单来说，当 Fiddler 当 作代理转发 HTTPS 请求的时候 ，就会产生“ CONNECT Tunnels ”。</p>
<p>这些握手验证请求对我们没什么用 处 ， 可以选择在 Fiddler 中将其隐藏掉。</p>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210102161600375.png" alt="image-20210102161600375"></p>
<h2 id="2-4-4-查看-Windows-本地安装的证书">2.4.4 查看 Windows 本地安装的证书</h2>
<p>用以下两种方法可 以打开 Windows 证书管理器：</p>
<ol>
<li>用键盘上的【Windows+R】快捷键调出【运行】窗口，在此窗口的输入框里输入【certmgr.msc】命令 。</li>
<li>在 Fiddler 的菜单栏中选择 Rules -&gt; Fiddler Options -&gt; HTTPS -&gt; Actions -&gt; Open Windows Certificate Manager，如图所示。在证书管理器中， 我们可以看到安装的 Fiddler 证书叫作“DO NOT TRUST FiddlerRoot ”</li>
</ol>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210102161902694.png" alt="image-20210102161902694"></p>
<h1>参考</h1>
<ul>
<li>《HTTP 抓包实战》</li>
</ul>
]]></content>
      <categories>
        <category>《HTTP 抓包实战》</category>
      </categories>
      <tags>
        <tag>http</tag>
        <tag>抓包</tag>
      </tags>
  </entry>
  <entry>
    <title>05 Web 网页抓包和 Fiddler 修改包</title>
    <url>/2020/01/09/HTTP%20%E6%8A%93%E5%8C%85%E5%AE%9E%E6%88%98/05%20Web%20%E7%BD%91%E9%A1%B5%E6%8A%93%E5%8C%85%E5%92%8C%20Fiddler%20%E4%BF%AE%E6%94%B9%E5%8C%85/</url>
    <content><![CDATA[<p>Fiddler 不但可以捕获到 HTTP 请求和 HTTP 响应，而且可以随意修改 HTTP 请求和 HTTP 响应，比如可以修改 HTTP 请求中的 Referer 、Cookie 等。可以通过“伪造“相应信息达到相应的目的，如可以模拟用户的请求等。</p>
<p>通过构造请求数据，可以突破表单的限制，随意提交数据；也可以绕过 JavaScript 和表单的限制来调试；还可以拦截 HTTP 响应，修改 HTTP 相应的 Header 和 Body。</p>
<a id="more"></a>
<h1>5.1 网页是如何打开的</h1>
<h2 id="5-1-1-一个网页的组成">5.1.1 一个网页的组成</h2>
<p>一个网页是由多个组件组成的。</p>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210103005515598.png" alt="image-20210103005515598"></p>
<h2 id="5-1-2-打开一个网页，浏览器需要发送很多个请求">5.1.2 打开一个网页，浏览器需要发送很多个请求</h2>
<p>在浏览器中，打开一个网页的过程如下。</p>
<ol>
<li>在浏览器输入 <a href="http://www.cnblogs.com">http://www.cnblogs.com</a></li>
<li>浏览器会发送第一个 HTTP 请求去获取页面布局的 HTML， 这个请求叫作“父请求”。然后服务器把 HTTP 响应发回给浏览器。</li>
<li>浏览器会分析 HTTP 响应中的 HTML 。如果发现 HTML 中引用了很多其他文件，比如图片、css 文件、js 文件等，浏览器会自动再次发送很多 HTTP 请求，去获取图片、css 文件或者 js 文件。这些 HTTP 请求 叫作“ 子请求”。</li>
<li>当所有子请求的响应都返回后，浏览器会把 1 个父请求加上多个子请求渲染出来。这样就形成了 一个页面，网页就在浏览器上显示出来</li>
</ol>
<h2 id="5-1-3-用-Fiddler-查看一个-Web-页面打开的过程">5.1.3 用 Fiddler 查看一个 Web 页面打开的过程</h2>
<p>启动 Fiddler，打开浏览器，输入 <a href="http://www.cnblogs.com/liqingwen">www.cnblogs.com/liqingwen</a></p>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210103011631433.png" alt="image-20210103011631433"></p>
<p>我们可以看到 Fiddler 捕获了很多 HTTP 请求，其中 <a href="http://www.cnblogs.com/liqingwen">http://www.cnblogs.com/liqingwen</a> 这个URL 是父请求，其他都是子请求。等所有请求的响应都结束后，浏览器才渲染页面。</p>
<p>如果没有采用 AJAX 技术，则某个子请求加载速度慢将会影响整个网页的加载速度。</p>
<h2 id="5-1-4-用-Fiddler-选择请求">5.1.4 用 Fiddler 选择请求</h2>
<ol>
<li>用 Fiddler 选择子请求 。 先找到父请求，鼠标右键选择 Select -&gt; Child Requests ，就能选中所有的子请求，或者按快捷键【C】</li>
</ol>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210103011838845.png" alt="image-20210103011838845"></p>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210116152712888.png" alt="image-20210116152712888"></p>
<ol start="2">
<li>用 Fiddler 选择父请求。找到任何一个子请求 ，鼠标右键选择 Select -&gt; Parent Requests，就能选中父请求，或者按快捷键【P】</li>
</ol>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210103011918524.png" alt="image-20210103011918524"></p>
<ol start="3">
<li>用 Fiddler 选择相同的请求。选择一个请求，鼠标右键选择 Select -&gt; Duplicate Requests，就能选中相同的请求了，或者按快捷键【D】</li>
</ol>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210103012003855.png" alt="image-20210103012003855"></p>
<h1>5.2 Web 页面简单的性能测试</h1>
<p>如上所述，一个网页的加载速度跟父请求和子请求都是有关系的。</p>
<ol>
<li>子请求出现了 404 或者 500 之类的错误，会严重影响整个网页的加载速度</li>
<li>子请求的响应速度慢也会影响网页加载的速度</li>
</ol>
<p>我们可以使用 Fiddler 来查看打开一个网页的每个请求的响应时间和状态码。启动 Fiddler 中的 Statistics 面板可以清楚地看到每个 HTTP 请求的响应时间。</p>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210116152858295.png" alt="image-20210116152858295"></p>
<p>Statistics 是一个详情和数据统计面板，显示了每条 HTTP 请求的具体统计信息，如发送和接收的字节数、发送和接收的时间，以及粗略统计的世界各地访问该服务器所花费的时间。</p>
<p>在 Overall Elapsed 中能看到 HTTP 响应返回所需要的响应时间。</p>
<h1>5.3 使用 Fiddler 来查看晌应</h1>
<p>HTTP 响应可能是一个 HTML 文档，可能是一个图片，也可能是一个 JSON。</p>
<p>使用 Raw 选项卡可以查看完整的 HTTP 响应，我们也可以用其他选项卡来查看。</p>
<p>如果 HTTP 响应的是 HTML 文档，则我们可以用 WebView 选项卡来查看。</p>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210116153124128.png" alt="image-20210116153124128"></p>
<p>如果 HTTP 响应是图片，那么我们可以用 ImageView 选项卡来查看。</p>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210103012508571.png" alt="image-20210103012508571"></p>
<p>如果 HTTP 响应是 JSON，我们可以通过 JSON tab 选项卡来格式化 JSON，这样查看起来更方便 。</p>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210116153245511.png" alt=""></p>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210103012559799.png" alt="image-20210103012559799"></p>
<h1>5.4 Fiddler 下断点，修改 HTTP 报文</h1>
<p>Fiddler 不但能抓包，还能改包 。想要修改 HTTP 报文，就需要先下断点拦截住 HTTP 请求报文或者 HTTP 响应报文，修改后再放行。</p>
<p>Fiddler 既能修改 HTTP 请求报文，也能修改 HTTP 响应报文。</p>
<h2 id="5-4-1-Fiddler-中设置断点修改-HTTP-请求">5.4.1 Fiddler 中设置断点修改 HTTP 请求</h2>
<p>Fiddler 本身是一个代理服务器， Fiddler 可以设置断点，拦截住 HTTP 请求，修改 HTTP 请求后再放行。</p>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210103012725500.png" alt="image-20210103012725500"></p>
<p>设置好断点后，你可以修改 HTTP 请求的任何信息，包括 Host 、Cookie 或者表单中的数据。设置断点有以下两种方法。</p>
<p>第一种叫全局断点 。启动 Fiddler，单击菜单栏中的 Rules -&gt; Automatic Breakpoint -&gt; Before Requests，或者使用快捷键【F11】，这种方法会拦截所有的会话。</p>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210103012922141.png" alt="image-20210103012922141"></p>
<p>要想取消全局断点，可以单击 Rules -&gt; Automatic Breakpoint -&gt; Disabled，或者使用快捷键【Shift+F11】。</p>
<p>第二种叫单个断点。己知某个请求 的 URL 地址，这时候只需要针对这一个请求打断点调试，其他的请求不拦截。</p>
<p>在 Fiddler 左下角的 QuickExec 命令行中输入命令“ bpu <a href="http://www.baidu.com">www.baidu.com</a> ”，这种方法只会拦截 <a href="http://www.baidu.com">www.baidu.com</a>。</p>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210103013113062.png" alt="image-20210103013113062"></p>
<p>要想消除单个断点，可以在命令行 中输入命令“ bpu ” 。</p>
<h2 id="5-4-2-实例：Fiddler-修改-HTTP-请求">5.4.2 实例：Fiddler 修改 HTTP 请求</h2>
<p>浏览器想访问 <a href="http://www.163.com">http://www.163.com</a>，可以通过 Fiddler 修改 HTTP 请求，让浏览器去访问 <a href="http://www.cnblogs.com/liqingwen%E3%80%82">www.cnblogs.com/liqingwen。</a></p>
<ol>
<li>启动 Fiddler ，在菜单栏中单击 Rules -&gt; Automatic Breakpoint -&gt; Before Requests</li>
<li>打开浏览器 ，输入“ <a href="http://www.163.com">www.163.com</a> ”，这时候会发现任务栏上的 Fiddler 图标在闪烁 ，说明 Fiddler 拦截住了 HTTP 请求</li>
<li>回到 Fiddler 界面，在菜单栏中单击 Rules -&gt; Automatic Breakpoint -&gt; Disable （因为己经拦截住想要 的 HTTP 请求了，其他 HTTP 请求就不需要拦截了）</li>
<li>被拦截的 HTTP 请求有一个红色的 T 图标，选中需要修改的 HTTP 请求 ，选中“ Inspectors＂面板，使用 Raw 选项卡（必须要在 Raw 选项卡下才能修改）</li>
<li>把 URL 修改为“ <a href="http://www.cnblogs.com/liqingwen%E2%80%9D%EF%BC%8C%E5%90%8C%E6%97%B6%E6%8A%8A">www.cnblogs.com/liqingwen”，同时把</a> HOST 修改为“<a href="http://www.cnblogs.com">www.cnblogs.com</a>”，然后单击绿色的“Run to Completion”按钮放行</li>
</ol>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210103013644127.png" alt="image-20210103013644127"></p>
<ol start="6">
<li>回到浏览器，此时我们会发现浏览器打开的是 cnblogs 的页面了</li>
</ol>
<p>如果单击黄色按钮“ Break on Response＂，则会继续拦截这个 HTTP 请求的响应。</p>
<h2 id="5-4-3-Fiddler-中设置断点修改-HTTP-响应">5.4.3 Fiddler 中设置断点修改 HTTP 响应</h2>
<p>当然 Fiddler 中也能修改 HTTP 响应。拦截住 HTTP 响应，修改 HTTP 响应后再放行。</p>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210103014135725.png" alt="image-20210103014135725"></p>
<p>设置断点，拦截 HTTP 响应也有 2 种方法，具体如下。</p>
<p>第一种是全局断点。启动 Fiddler，单击 Rules -&gt; Automatic Breakpoint -&gt; After Response。这种方法会中断所有的会话。</p>
<p>要想取消全局断点，可以单击 Rules -&gt; Automatic Breakpoint -&gt; Disabled 。</p>
<p>第二种是单个断点。 在命令行 中输入命令“ bpafter <a href="http://www.baidu.com">www.baidu.com</a>＂ 。 这种方法只会中断 <a href="http://www.baidu.com">www.baidu.com</a> 。</p>
<p>要想消除单个断点，可以在命令行中输入命令“ hpafter”。</p>
<h2 id="5-4-4-Fiddler-修改网页的标题">5.4.4 Fiddler 修改网页的标题</h2>
<p>【实例】用户访问 一个网页，通过 Fiddler 修改响应的方法修改网页的标题 。具体操作步骤如下</p>
<ol>
<li>启动 Fiddler，在左下角的 QuickExec 命令行中输入“ bpafter <a href="https://www.cnblogs.com/liqingwen/p/7087990.html">https://www.cnblogs.com/liqingwen/p/7087990.html</a>&quot;</li>
</ol>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210116155038805.png" alt="image-20210116155038805"></p>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210103014509409.png" alt="image-20210103014509409"></p>
<ol start="2">
<li>
<p>打开浏览器，输入“ <a href="https://www.cnblogs.com/liqingwen/p/7087990.html">https://www.cnblogs.com/liqingwen/p/7087990.html</a> ”</p>
</li>
<li>
<p>在 Fiddler 中选中“<a href="https://www.cnblogs.com/liqingwen/p/7087990.html%E2%80%9C%EF%BC%8C%E9%80%89%E4%B8%AD%E2%80%9CInspectors">https://www.cnblogs.com/liqingwen/p/7087990.html“，选中“Inspectors</a> ”面板，Response 下使用 Raw 选项卡（必须要在 Raw 选项卡下才能修改）。</p>
</li>
<li>
<p>修改 HTML 代码为 <code>&lt;title&gt;我修改了这里＜/title&gt;</code>，然后单击 <code>Run to Completion</code> 放行</p>
</li>
</ol>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210103014905572.png" alt="image-20210103014905572"></p>
<ol start="5">
<li>在浏览器中查看网页的标题</li>
</ol>
<h2 id="5-4-5-伪造-Referer">5.4.5 伪造 Referer</h2>
<p>如果没有 Referer，有些网站会认为是盗链。我们现在使用 Fiddler 来伪造一个 Referer：</p>
<ol>
<li>启动 Fiddler，设置一个全局断点，在菜单栏中单击 Rules -&gt; Automatic Breakpoint -&gt; Before Requests</li>
<li>打开浏览器，输入 <a href="https://img3.laibafile.cn/p/m/280148719.png">https://img3.laibafile.cn/p/m/280148719.png</a></li>
<li>这时候，Fiddler 会拦截到该请求。在 Raw 选项卡上修改 HTTP 请求，添加一个 <code>Refere:www.tianya.cn</code>。</li>
</ol>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210103015256721.png" alt="image-20210103015256721"></p>
<ol start="4">
<li>单击绿色的 <code>Run to Completion</code> 按钮放行，我们发现浏览器中能看到真正的图片。</li>
</ol>
<h1>参考</h1>
<ul>
<li>《HTTP 抓包实战》</li>
</ul>
]]></content>
      <categories>
        <category>《HTTP 抓包实战》</category>
      </categories>
      <tags>
        <tag>http</tag>
        <tag>抓包</tag>
      </tags>
  </entry>
  <entry>
    <title>06 HTTP 协议中的缓存</title>
    <url>/2020/01/09/HTTP%20%E6%8A%93%E5%8C%85%E5%AE%9E%E6%88%98/06%20HTTP%20%E5%8D%8F%E8%AE%AE%E4%B8%AD%E7%9A%84%E7%BC%93%E5%AD%98/</url>
    <content><![CDATA[<p>了解这些缓存机制对提高网站的性能非常有帮助。</p>
<a id="more"></a>
<h1>6.1 缓存的概念</h1>
<p>HTTP 中具有缓存功能的是浏览器缓存和代理服务器缓存。</p>
<p>HTTP 缓存是指当 Web 请求抵达缓存时，如果本地有“己缓存 的”副本，就可以从本地存储设备而不是从原始服务器中提取这个文档 。</p>
<h1>6.2 缓存的优点</h1>
<p>缓存的好处：</p>
<ol>
<li>减少了冗余的数据传输，节省了传输时间</li>
<li>减少了服务器的负担，可以让服务器去处理更多请求</li>
<li>加快了客户端加载网页的速度</li>
</ol>
<h1>6.3 Fiddle 可以方便地查看缓存的 Header</h1>
<p>Fiddler 中的 Header 选项卡已经把 Header 进行分类摆放，把跟 Cache 相关的 Header 放在一起，这样方便查看。</p>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210103030537853.png" alt="image-20210103030537853"></p>
<h1>6.4 如何判断缓存新鲜度</h1>
<p>Web 服务器通过以下 2 种方式来判断浏览器缓存是否最新：</p>
<ol>
<li>浏览器把缓存文件的最后修改时间通过 Header “ If-Modified-Since＂告诉 Web 服务器</li>
<li>浏览器把缓存文件的 ETag 通过 Header “ If-None-Match ＂告诉 Web 服务器</li>
</ol>
<h1>6.5 通过最后修改时间来判断缓存新鲜度</h1>
<p>浏览器可以通过缓存文件的修改时间来判断缓存的新鲜度 。</p>
<ol>
<li>
<p>如果浏览器客户端想请求一个文档，它首先检查本地缓存 ，发现存在这个文档的缓存，获取缓存中文档的最后修改时间，通过“ If-Modified -Since ＂发送 HTTP 请求给 Web 服务器</p>
</li>
<li>
<p>Web 服务器收到 HTTP 请求，将服务器的文档修改时间（ Last-Modified ）跟 HTTP 请求 Header 中的 If-Modified-Since 相比较。如果时间是一样的，说明缓存还是最新的，Web 服务器将发送状态码 304 (Not Modified ） 给浏览器客户端，告诉客户端直接使用缓存里的版本</p>
</li>
</ol>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210103030840728.png" alt="image-20210103030840728"></p>
<ol start="3">
<li>假如该文档己经被更新了，Web 服务器将发送该文档的最新版本给浏览器客户端</li>
</ol>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210103030904507.png" alt="image-20210103030904507"></p>
<p>【实例】启动 Fiddler，然后打开博客园首页 。 按快捷键【F5】刷新几次浏览器，会看到博客园首页也用了缓存 。</p>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210103031024349.png" alt="image-20210103031024349"></p>
<h1>6.6 与缓存有关的 Header</h1>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210103031052930.png" alt="image-20210103031052930"></p>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210103031125096.png" alt="image-20210103031125096"></p>
<p>如果同时存在 cache-control 和 Expires 怎么办呢？</p>
<ul>
<li>浏览器总是优先使用 cache-control</li>
<li>如果没有 cache-control 才考虑 Expires</li>
</ul>
<h1>6.7 ETag</h1>
<p>ETag 是 Entity Tag（实体标签）的缩写，是根据实体内容生成的一段 hash 字符串（类似于 MD5 或者 SHA1 之后的结果），可以标识资源的状态。当资源发生改变时，ETag 也随之发生变化。</p>
<p>ETag 是 Web 服务端产生的，然后发给浏览器客户端。浏览器客户端不用关心 ETag 是如何产生的。</p>
<p>使用 ETag 主要是为了解决一些 Last-Modified 无法解决的问题。</p>
<ol>
<li>某些服务器不能精确得到文件的最后修改时间，这样就无法通过最后修改时间来判断文件是否更新了</li>
<li>某些文件的修改非常频繁，在以秒为单位以下的时间内进行修改，而 Last-Modified 只能精确到秒</li>
<li>一些文件的最后修改时间改变了，但是内容并未改变，我们不希望客户端认为这个文件修改了</li>
</ol>
<p>【实例】启动 Fiddler，然后打开博客园首页。可以看到很多图片或者 css 文件都使用了缓存。这些都是通过比较 ETag 的值来判断文件是否更新了。</p>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210103031539301.png" alt="image-20210103031539301"></p>
<h1>6.8 浏览器不使用缓存</h1>
<p>使用【Ctrl+F5】快捷键强制刷新浏览器，可以让浏览器不使用缓存：</p>
<ol>
<li>浏览器发送 HTTP 请求给 Web 服务器，Header 中带有 Cache-Control: no-cache，明确告诉 Web 服务器客户端不使用缓存</li>
<li>Web 服务器将把最新的文档发送给浏览器客户端</li>
</ol>
<p>【实例】启动 Fiddler，打开博客园首页，然后按【Ctr l+F5】快捷键强制刷新浏览器。你将看到浏览器发送的 HTTP 请求中有“ Cache-Control:no-cache ”</p>
<ul>
<li>“Pragma: no-cache＂的作用和“ Cache-Control: no-cache”一模一样，都是不使用缓存</li>
<li>“Pragma: no-cache ”是 HTTP 1.0 中定义的，所以为了兼容 HTTP 1.0 会同时使用“ Pragma:no-cache ”和“ Cache-Control: no-cache ”</li>
</ul>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210103031850336.png" alt="image-20210103031850336"></p>
<h1>6.9 直接使用缓存，不去服务器验证</h1>
<p>按【F5】快捷键刷新浏览器并在地址栏里输入网址，然后按回车键，这两个行为是不一样的。</p>
<p>按【F5】快捷键刷新浏览器，浏览器会去 Web 服务器验证缓存。</p>
<p>如果是在地址栏输入网址然后按回车键，浏览器会“直接使用有效的缓存”，而不会发送 HTTP 请求去服务器验证缓存，这种情况叫作缓存命中。</p>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210103032130483.png" alt="image-20210103032130483"></p>
<p>【实例】比较第一次访问博客园主页和第二次访问博客园主页</p>
<ol>
<li>启动 Fiddler，打开 Firefox，打开博客园主页 hhttp://www.cnblogs.com，发现有 50 多个 Session</li>
<li>按【Ctrl+X】快捷键将 Fiddler 中的所有 Session 删除</li>
<li>关闭 Firefox 后，然后再次打开博客园主页，可以看到只有 30 多个 Session。</li>
</ol>
<p>【分析】少了很多 Session 是因为 Firefox 直接使用了缓存，而没有发送 HTTP 请求。</p>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210103032453779.png" alt="image-20210103032453779"></p>
<h1>6.10 如何设置 IE 不使用缓存</h1>
<p>打开 IE ，单击工具栏上的工具 -&gt; Internet 选项 -&gt; 常规 -&gt; 浏览历史记录 -&gt; 设置，选择“从不”，然后保存，可以让浏览器不使用缓存。</p>
<p>单击“删除”，可以把 Internet 临时文件都删掉（IE 缓存的文件就是 Internet 临时文件）。</p>
<p>缓存文件都保存在一个文件夹下，这个文件夹可以这样找到：打开 IE，单击工具栏上的工具 -&gt; Internet 选项 -&gt; 常规 -&gt; 浏览历史记录 -&gt; 设置 -&gt; 查看文件。</p>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210103032730799.png" alt="image-20210103032730799"></p>
<h1>6.11 公布缓存和私有缓存的区别</h1>
<p>“ Cache-Control:public ”指可 以公有缓存 ，缓存可以由数千名用户共享。“ Cache-Control:private ＂ 指只支持私有缓存，私有缓存是单个用户专用的。</p>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210103032848554.png" alt="image-20210103032848554"></p>
<h1>参考</h1>
<ul>
<li>《HTTP 抓包实战》</li>
</ul>
]]></content>
      <categories>
        <category>《HTTP 抓包实战》</category>
      </categories>
      <tags>
        <tag>http</tag>
        <tag>抓包</tag>
      </tags>
  </entry>
  <entry>
    <title>07 HTTP 协议压缩和 URL Encode</title>
    <url>/2020/01/09/HTTP%20%E6%8A%93%E5%8C%85%E5%AE%9E%E6%88%98/07%20HTTP%20%E5%8D%8F%E8%AE%AE%E5%8E%8B%E7%BC%A9%E5%92%8C%20URL%20Encode/</url>
    <content><![CDATA[<p>HTTP 压缩是指 Web 服务器和浏览器之间压缩传输“ 文本内容” 的方法。HTTP 采用通用的压缩算法，比如用 gzip 来压缩 HTTP、JavaScript、css 文件，能大大减少网络传输的数据量，提高了用户显示网页的速度。当然，这同时也会增加一点点服务器的开销。</p>
<a id="more"></a>
<h1>7.1 HTTP 压缩的过程</h1>
<ol>
<li>浏览器发送 HTTP 请求给 Web 服务器，请求中的 Header 能 <code>Accept-Encoding: gzip</code>，deflate（告诉服务器，浏览器支持 gzip 压缩）。</li>
<li>Web 服务器接到 HTTP 请求后，生成原始的 HTTP 响应，其中有原始的 Content-Type 和 Content-Length。</li>
<li>Web 服务器通过 gzip 来对 HTTP 响应进行编码，编码后 Header 中有 Content-Type 和 Content-Length（压缩后的大小），并且增加了 <code>Content-Encoding:gzip</code>，然后把 HTTP 响应发送给浏览器</li>
<li>浏览器接到 HTTP 响应后，根据 <code>Content-Encoding:gzip</code> 来对 HTTP 响应进行解码，获取到原始 HTTP 响应后显示出网页</li>
</ol>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210109003334055.png" alt="image-20210109003334055"></p>
<h2 id="7-1-1-实例-Fiddler-观察-HTTP-压缩">7.1.1 实例 Fiddler 观察 HTTP 压缩</h2>
<p>我们可以使用 Fiddler 来捕获网站、 查看压缩。比如博客园就使用了 gzip 压缩。启动 Fiddler，在浏览器中打开 <a href="https://www.cnblogs.com">https://www.cnblogs.com</a>，可以看到 HTTP 响应是乱码，并且出现了一个长长的黄色按钮 <code>Responsebody is encoded.Click to decode.</code>。单击这个按钮就可以解压 HTTP 响应。</p>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210109003617340.png" alt="image-20210109003617340"></p>
<p>在 Fiddler 中，每次都要手动去 Decode 实在太麻烦。单击工具栏上的“ Decode ”按钮，就可以自动解压了。</p>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210109003651570.png" alt="image-20210109003651570"></p>
<h1>7.1.2 内容编码类型</h1>
<p>HTTP 定义了 一些标准的内容编码类型，并允许用扩展的形式添加更多的编码。</p>
<p>Conte-Encoding header 就是用这些标准化的代号来说明编码时使用的算法。</p>
<p>gzip 表明实体采用 GNU zip 编码 。</p>
<p>compress 表明实体采用 UNIX 的文件压缩程序 。</p>
<p>deflate 表明实体是用 zlib 的格式压缩的 。</p>
<p>identity 表明没有对实体进行编码；当没有 Content-Encoding header 时，就默认为这种情况。</p>
<p>gzip、compress 以及 deflate 编码都是无损压缩算法，用于减少传输报文的大小，不会导致信息损失。其中 gzip 通常效率最高，使用最为广泛。</p>
<h2 id="7-1-3-压缩的好处">7.1.3 压缩的好处</h2>
<p>减少了数据传输，节省了带宽资源。</p>
<p>【实例】博客园首页压缩前的大小是 46171 bytes，压缩后的大小是 12082 bytes，只有原来的 35%，节省了 65% 的数据传输，从而大大提高了性能。</p>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210109003956583.png" alt="image-20210109003956583"></p>
<h2 id="7-1-4-gzip-的不足之处">7.1.4 gzip 的不足之处</h2>
<p>JPEG 这类文件用 gzip 压缩的效果不够好，gzip 占用了一些服务器和客户端的 CPU。</p>
<h2 id="7-1-5-gzip-是如何压缩的">7.1.5 gzip 是如何压缩的</h2>
<p>简单来说，gzip 压缩是在一个文本文件中找出类似的字符串，并临时替换它们，从而使整个文件变小。这种形式的压缩对 Web 来说非常适合，因为 HTML 和 css 文件通常包含大量重复的字符串，例如空格、标签。</p>
<h2 id="7-1-6-HTTP-请求也是可以编码的">7.1.6 HTTP 请求也是可以编码的</h2>
<p>浏览器一般不会对 HTTP 请求编码，但是一些程序在发送 HTTP 请求时会对其进行编码。</p>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210109004146924.png" alt="image-20210109004146924"></p>
<h2 id="7-1-7-HTTP-内容编码和-HTTP-压缩的区别">7.1.7 HTTP 内容编码和 HTTP 压缩的区别</h2>
<p>在 HTTP 协议中，可以对内容（也就是 Body 部分）进行编码，如可以采用 gzip 这样的编码，从而达到压缩的目的；也可以使用其他的编码方式把内容搅乱或加密，以此来防止未被授权的第三方看到文档的内容 。</p>
<p>所以，我们说 HTTP 压缩其实就是 HTTP 内容编码的一种，不要把 HTTP 压缩和 HTTP 内容编码两个概念混淆了。</p>
<h1>7.2 URL Encode 介绍</h1>
<p>URL Encode (URL 编码）就是把所有非英文字母、数字字符都替换成百分号（%）后加两位十六进制数，比如空格的编码为“ %20”。</p>
<h2 id="7-2-1-查询字符串中包含汉字">7.2.1 查询字符串中包含汉字</h2>
<p>打开 Firefox 浏览器，输入网址：<a href="https://www.baidu.com/s?wd=%E5%B0%8F%E5%9D%A6%E5%85%8B">https://www.baidu.com/s?wd=小坦克</a></p>
<ul>
<li>【注意】“小坦克”属于查询字符串，不属于网址路径</li>
</ul>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210109004526325.png" alt="image-20210109004526325"></p>
<p>用 Fiddler 抓包，我们发现，实际的网址是 <a href="https://www.baidu.com/s?wd=%E5%B0%8F%E5%9D%A6%E5%85%8B">https://www.baidu.com/s?wd=小坦克</a></p>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210109004612215.png" alt="image-20210109004612215"></p>
<p>Firefox 自动把“小坦克”编码成了“ %E5%B0%8F%E5%9D%A6%E5%85%8B ”。</p>
<h2 id="7-2-2-POST-中的数据包含汉字">7.2.2 POST 中的数据包含汉字</h2>
<p>启动 Fiddler，在浏览器中打开 <a href="https://account.cnblogs.com">https://account.cnblogs.com</a>，输入注册信息进行注册，这样我们能捕获到 POST 的一些数据。</p>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210109004727534.png" alt="image-20210109004727534"></p>
<p>我们可以看到 body 里面的数据同样被编码了：“ ＠”转义成了“ %4。”，汉字也被转义成了“%E5%B0%8F%E5%9D%A6%E5%85%8B2 ” 。</p>
<p>POST 中的主体在传输的时候同样会被转义。</p>
<h1>7.3 Fiddler 中的 TextWizard</h1>
<p>我们经常需要进行字符编码，比如把字符进行 URL Encode 或者 URL Decode 。 我们可以使用 TextWizard 来对字符编码。</p>
<p>单击 Fiddler 工具栏 中的“ TextWizard ”，可以启动 TextWizard 小工具。</p>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210109004839664.png" alt="image-20210109004839664"></p>
<h1>参考</h1>
<ul>
<li>《HTTP抓包实战》</li>
</ul>
<h1>修改</h1>
<p>创建时间：2021–01-09 00:49</p>
]]></content>
      <categories>
        <category>《HTTP 抓包实战》</category>
      </categories>
      <tags>
        <tag>http</tag>
        <tag>抓包</tag>
      </tags>
  </entry>
  <entry>
    <title>08 Fiddle 使用技巧</title>
    <url>/2020/01/09/HTTP%20%E6%8A%93%E5%8C%85%E5%AE%9E%E6%88%98/08%20Fiddle%20%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/</url>
    <content><![CDATA[<p>这里介绍了常见的使用技巧。</p>
<a id="more"></a>
<h1>8.1 Fiddler 和其它抓包软件的比较</h1>
<p>与 Fiddler 同类的抓包软件还有 Charles 、Firebug 、Wireshark、HTTPWatch 等。</p>
<p>优势：</p>
<ol>
<li>Fiddler 可以通过 FiddlerScript 写脚本来扩展功能，Charles 则不能</li>
<li>使用 Charles 要付费 ，Fiddler 可免费使用</li>
<li>Charles 是跨平台的（Windows 、Mac 、Linux)，Fiddler 现在同样也是跨平台的了( Windows 、 Mac、Linux）。</li>
<li>HTTPWatch 也是比较常见的 HTTP 抓包工具 ，但是只支持 IE 和 Firefox 浏览器 ，而且不能修改 HTTP 包</li>
<li>Wireshark 支持更多的协议，主要是用来监昕 TCP/IP 协议，直接与网卡进行数据报文交互
<ul>
<li>如果用 Wireshark 来监控 HTTP 协议， 就有点大材小用，而且不方便</li>
</ul>
</li>
</ol>
<h1>8.2 Fiddler 抓不到包应该怎么解决</h1>
<p>如果 Fiddler 不能捕获数据包，可以尝试：</p>
<ol>
<li>先确定是 HTTP 包抓不到，还是 HTTPS 包抓不到
<ul>
<li>如果只是 HTTPS 包抓不到，说明是证书的问题，需要重新安装证书</li>
</ul>
</li>
<li>检查浏览器的 HTTP 代理设置是否正确，或者换个浏览器试试</li>
<li>检查 Fiddler 的捕获开关是否打开</li>
<li>检查过滤的设置</li>
<li>确定是否是捕获 Localhost 的流量</li>
</ol>
<h1>8.3 如何找到想抓的包</h1>
<p>启动 Fiddler, Web Sessions 列表就会抓到很多 HTTP 请求，我们需要找的 HTTP 请求被淹没其中。</p>
<p>我们在抓包之前，可以先把 Web Sessions 列表清空，然后再操作，这样 Web Sessions 中抓到的 HTTP 请求就会少很多。</p>
<p>有以下几种方法可以清空 Web Session 列表。</p>
<ol>
<li>第一种方法：Fiddler 菜单栏上有一个 × 图标，单击小箭头后会看到“ Remove all“，选项，选此即可以清空 Web Session 列表 。</li>
<li>第二种方法：单击 Web Session 列表中的任何一个 HTTP 请求，并按快捷键【 CTRL+X 】。</li>
<li>第三种方法：在 QuickExec 命令行工具中输入命令“ cls ”，按回车键，也可以清空 Web Sessions 列表。</li>
</ol>
<p>抓到自己想要的包后，应该让 Fiddler 暂停抓包，这样就不会因为抓到一些不相干的包而被干扰了。</p>
<h1>8.4 Fiddler 异常退出后无法上网</h1>
<p>电脑意外死机，Fiddler 异常退出后会导致电脑无法上网。原因是 Fiddler 异常退出后，没有注销代理，系统的代理仍然是 127.0.0.1 ，端口号是 8888 。</p>
<p>解决的办法是重新启动 Fiddler 再关闭，这样浏览器就能上网了。</p>
<h1>8.5 Fiddler 排序</h1>
<p>Fiddler 中的 Web Session 默认是按照序号排序的，可能某种误操作会让 Web Session 按照别的标准排序，导致用户找不到抓的包。</p>
<p>我们可以单击“序号”的列名，重新按照序号来排序。</p>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210109012316668.png" alt="image-20210109012316668"></p>
<h1>8.6 Fiddler 中查询会话</h1>
<p>在菜单栏中单击 Edit -&gt; Find Sessions ，或者用快捷键【Ctrl + F】打开“ Find Sessions”的对话框，输入关键宇查询你要的会话。查询到的会话会以黄色显示。</p>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210116161624258.png" alt="image-20210116161624258"></p>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210109012505357.png" alt="image-20210109012505357"></p>
<p>【注意】汉字或者特殊字符很可能查询不到，因为在 HTTP 请求中，汉字或者特殊字符被转义了。</p>
<h1>8.7 Fiddler 中保存抓到的包</h1>
<p>有些时候我们 需要把会话保存下来，以便发给别人或者以后去分析。保存会话的步骤如下：</p>
<ol>
<li>选择你想保存的会话，然后单击 File -&gt; Save -&gt; Selected Sessions。保存后的文件后缀名是 .saz。文件中会保存完整的 HTTP 请求和 HTTP 响应；</li>
<li>双击 .saz 文件，或者单击 Fiddler 菜单栏中的 File -&gt; Load Archive，就能打开 . saz 文件。</li>
</ol>
<h1>8.8 Fiddler 中编辑会话</h1>
<p>默认的情况下，Fiddler 中的 Session 是不能编辑的。</p>
<p>选择一个 Session，用鼠标右键选择“ Unlock For Editing&quot;（快捷键是【F2】），这样就可以在 Inspectors 的 Raw 模式下编辑 HTTP 请求和 HTTP 响应 。</p>
<h1>8.9 过滤会活</h1>
<p>每次启动 Fiddler，打开一个网页，都能看到几十个会话，看得人眼花缭乱。这时候我们可以使用 Filter 的功能来过滤，使网页只显示自己想要的 HTTP 请求。</p>
<p>在 Fiddler 中找到 Filters 选项卡，选中“ Use Filters ”，就可以启动过滤功能。</p>
<p>Filters 的 Actions 中，我们可以保存好当前的过滤配置，也可以加载己经保存好的过滤配置。</p>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210109012835497.png" alt="image-20210109012835497"></p>
<h1>8.10 常用快捷键</h1>
<p>Fiddler 中的 Web Sessions 是我们用得最多的地方。通常我们必须选择 Web Sessions 中的 Session，然后做其他的操作。</p>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210109012912926.png" alt="image-20210109012912926"></p>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210109013025365.png" alt="image-20210109013025365"></p>
<h1>8.11 QuickExec 命令行的使用</h1>
<p>Fiddler 的左下角有一个命令行工具叫作 QuickExec，允许你直接输入命令。</p>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210109013056752.png" alt="image-20210109013056752"></p>
<p>常见的命令：</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>help</td>
<td>打开官方的使用页面介绍，所有的命令都会列出来</td>
</tr>
<tr>
<td>cls</td>
<td>清屏（【Ctrl+X】快捷键也可以清屏）</td>
</tr>
<tr>
<td>select</td>
<td>选择会话的命令</td>
</tr>
<tr>
<td>?.png</td>
<td>用来选择 .png 后缀的图片</td>
</tr>
<tr>
<td>bpu</td>
<td>截获 request</td>
</tr>
</tbody>
</table>
<p>还可以用“ urlreplace <a href="http://www.tank-dev.com">www.tank-dev.com</a> <a href="http://www.tank-demo.com">www.tank-demo.com</a> ”替换掉 host</p>
<p>我们最初发送给 A 站点的 HTTP 请求，都被 Fiddler 转发到 B 站点，而在浏览器中毫无感觉 。 测试或者 debug 过程中经常会有这种需求。</p>
<h1>8.12 Fiddler 比较会话的不同</h1>
<p>如果需要比较两个 Session 的内容的不同，我们可以使用 Windiff 工具。具体操作步骤如下 。</p>
<ol>
<li>下载 WinDiff</li>
<li>在 Fiddler 中设置 Compare 工具为 WinDiff。启动 Fiddler ，在菜单栏中单击 Tools -&gt; Fiddler Options ，在 Tools 选项卡中选择 WinDiff 的路径</li>
</ol>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210116162321980.png" alt="image-20210116162321980"></p>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210109013633172.png" alt="image-20210109013633172"></p>
<ol start="3">
<li>选中两个会话，用鼠标右键选择 Compare ，就可以使用 WinDiff 来比较两个会话的不同了</li>
</ol>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210109013656273.png" alt="image-20210109013656273"></p>
<h1>8.13 Fiddler 插件</h1>
<p>Fiddler 的插件下载地址是：<a href="http://www.telerik.com/fiddler/add-ons">http://www.telerik.com/fiddler/add-ons</a> 。</p>
<h2 id="8-13-1-JavaScript-Formatter">8.13.1 JavaScript Formatter</h2>
<p>从服务器返回来的 JavaScript 代码都没有格式化 。 利用 Java Script Formatter 插件可以格式化 JavaScript 代码，增加可读性。</p>
<p>安装好 Java Script Formatter 插件后，在 Fiddler 中选择一个 Session，用鼠标右键选择“ Make JavaScript Pretty ”，就可以格式化  JavaScript 代码了。</p>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210109013828261.png" alt="image-20210109013828261"></p>
<h2 id="8-13-2-Gallery-插件">8.13.2 Gallery 插件</h2>
<p>选择很多图片的会话后，Gallery 插件可以显示这些图片的缩略图。</p>
<p>假如所有的插件都不能满足你的需求，那么你只能自己开发插件了 。</p>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210109013939527.png" alt="image-20210109013939527"></p>
<h1>参考</h1>
<ul>
<li>《HTTP抓包实战》</li>
</ul>
]]></content>
      <categories>
        <category>《HTTP 抓包实战》</category>
      </categories>
      <tags>
        <tag>http</tag>
        <tag>抓包</tag>
      </tags>
  </entry>
  <entry>
    <title>04 HTTP 协议 Header 介绍</title>
    <url>/2020/01/09/HTTP%20%E6%8A%93%E5%8C%85%E5%AE%9E%E6%88%98/04%20HTTP%20%E5%8D%8F%E8%AE%AE%20Header%20%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<p>HTTP 请求和 HTTP 响应中有很多 Header, HTTP 请求方法和 HTTP Header 配合工作，共同决定客户端和服务器能做什么事情。</p>
<a id="more"></a>
<h1>4.1 HTTP Header 介绍</h1>
<p>HTTP 请求中有 Header, HTTP 响应中也有 Header。使用 Fiddler 的 Raw 选项卡可以看到完整的 Header 。</p>
<p>Header 的语法格式是“ key:value“，一行一个 Header。每一个 Header 都有特殊的作用，在 Fiddler 中可以查看完整的 Header。</p>
<h1>4.2 Fiddler 查看 HTTP 请求 Header</h1>
<p>使用 Fiddler 能很方便地查看 HTTP 请求 Header。选中一个 HTTP 请求，单击 Inspectors tab -&gt; Request tab -&gt; Headers</p>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210102202029040.png" alt="image-20210102202029040"></p>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210102202050809.png" alt="image-20210102202050809"></p>
<h2 id="4-2-1-Cache-相关的-Header">4.2.1 Cache 相关的 Header</h2>
<p>HTTP 请求和 HTTP 响应中都有很多用于缓存的 Header。</p>
<p>HTTP 缓存是指当 Web 请求抵达缓存时，如果本地有“己缓存的”副本，就可以从本地存储设备而不是从原始服务器中提取这个文档。</p>
<h2 id="4-2-2-Cookies">4.2.2 Cookies</h2>
<p>Cookie 是一种 HTTP Header，是 HTTP 中非常重要 的内容 。它由 key=value 的形式组成，比如 ip_coun町＝CN 。</p>
<p>浏览器把 Cookie 通过 HTTP 请求中的“ Cookie:header，，发送给 Web 服务器，Web 服务器通过 HTTP 响应中的“Set-Cookie:header“ ，把 Cookie 发送给浏览器。</p>
<h2 id="4-2-3-Accept">4.2.3 Accept</h2>
<p>Accept 表示浏览器客户端可 以接受的媒体类型。</p>
<p>例如，Accept:text/html 代表浏览器可 以接受服务器返回 html ，也就是我们通常说的 html 文档。</p>
<p>通配符＊代表任意类型 ， 例如 Accept: text/html,*/*;q=0. 8 代表浏览器可以处理所有的类型。一般浏览器客户 端给 Web 服务器发送的都是这个 。</p>
<h2 id="4-2-4-Accept-Encoding">4.2.4 Accept-Encoding</h2>
<p>Accept-Encoding 跟压缩有关，浏览器发送 HTTP 请求给 Web 服务器， HTTP 请求中的 Header 有 Accept-Encoding: gzip, deflate （告诉服务器 ，浏览器支持 gzip 压缩〉。</p>
<h2 id="4-2-5-Accept-Language">4.2.5 Accept-Language</h2>
<p>Accept-Language 的作用是浏览器声明自己接受的语言</p>
<p>语言跟字符集的区别在于：中文是语言，中文有多种字符集，比如 big5、gb2313 、gbk 等。示例如下：</p>
<p>Accept-Language: en-US ,en ; q=0.8,zh-CN;q=0.6,zh;q=0.4,zh-TW; q=0 .2</p>
<h2 id="4-2-6-User-Agent">4.2.6 User-Agent</h2>
<p>User-Agent 的作用是浏览器用来告诉服务器，客户端使用的操作系统及版本、CPU 类型、浏览器及版本、浏览器渲染引擎、浏览器语言、浏览器插件等。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">User-Agent: Mozilla&#x2F;5.0(Windows NT 10.0; WOW64; rv:40.0) Gecko&#x2F;20100101 Firefox&#x2F;40.0&lt;br&gt;</span><br></pre></td></tr></table></figure>
<p>这个代表客户端用的是 64 位 winlO 系统，Firefox 是 40.0 版本 。</p>
<p>假如用于机的 APP 访问网站，APP 中的 HTTP 请求可能会包含如下的 User-Agent:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">User-Agent:Dalvik&#x2F;2.1.0 (Linux; U; Android 6.0; Redmi Note 4 MIUI&#x2F; V8.5.2.0.MBFCNED)</span><br></pre></td></tr></table></figure>
<p>这个 User-Agent 表示客户 端用的是红米 Note 4, Android 6.0 版本。</p>
<p>如果我们想模拟各种不同的客户端，只需要修改 User-Agent，就可以伪装成各种客户端。</p>
<h2 id="4-2-7-实例：Fiddler-修改-User-Agent，伪装客户端">4.2.7 实例：Fiddler 修改 User-Agent，伪装客户端</h2>
<p>Fiddler 可以 帮我们修改 User-Agent，这样就能伪装成任何客户端 。操作步骤如下：</p>
<ol>
<li>启动 Fiddler ，单击 Rules -&gt; User-Agents ，选择 iPhone6</li>
</ol>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210102203312191.png" alt="image-20210102203312191"></p>
<ol start="2">
<li>
<p>打开浏览器，输入 <a href="http://www.taobao.com">http://www.taobao.com</a>，可以看到淘宝的页面变成了移动版的淘宝页面</p>
</li>
<li>
<p>在 Fiddler 中，我们可以查看 User-Agent 的值如下：</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">User-Agent: Mozilla&#x2F;5.0 (iPhone; CPU iPhone OS 8_3 like Mac OS X) AppleWebKit&#x2F;600.1.4 (KHTML, like Gecko) Version&#x2F;8.0 Mobile&#x2F;12F70 Safari&#x2F;600.1.4</span><br></pre></td></tr></table></figure>
<h2 id="4-2-8-Referer">4.2.8 Referer</h2>
<p>HTTP 协议头中的 Referer 主要用来让服务器判断来源页面，即用户是从哪个页面来的。网站通常用其来统计用户来源，看用户是从搜索页面来的，还是从其他网站链接过来的，或是从书签等访问的，以便合理定位网站 。</p>
<p>Referer 有时也被用作防盗链，即下载时判断来源地址是不是在网站域名之内，否则就不能下载或显示 。 很多网站，如天涯就是通过 Referer 页面来判断用户是否能够下载图片的 。</p>
<p>【实例】天涯网站中的 图片会验证 Referer：如果没有 Referer，网站会认为是盗链。</p>
<ol>
<li>在 <a href="http://www.tianya.cn">http://www.tianya.cn</a> 中找到 一 张图片的网址 ，例如 <a href="http://img3.laibafile.cn/p/m/280148719.png">http://img3.laibafile.cn/p/m/280148719.png</a></li>
<li>启动 Fiddler，打开浏览器 ， 直接输入 <a href="http://img3.laibafile.cn/p/m/280148719.png">http://img3.laibafile.cn/p/m/280148719.png</a></li>
<li>我们可以看到图片上显示“该图片仅供天涯社区用户分享 ”</li>
<li>在 Fiddler 中可以看到 HTTP 请求中没有 Referer，所以被 Web 服务器认为是盗链。</li>
</ol>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210102203810102.png" alt="image-20210102203810102"></p>
<h2 id="4-2-9-Connection">4.2.9 Connection</h2>
<p>从 HTTP/1.1 起，系统默认都开启了 <code>Connection:Keep-Alive</code>，保持连接特性。</p>
<p>HTTP 协议是基于 TCP 协议的 。当一个网页完全打开后 ，客户端和服务器之间用于传输 HTTP 数据的 TCP 连接不会关闭；如果客户端再次访问这个服务器上的网页，将会继续使用这一条己经建立的连接。</p>
<p>Keep-Alive 不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如 Apache）中设定这个时间。</p>
<h2 id="4-2-10-Host">4.2.10 Host</h2>
<p>Host 这个 Header 是必需的，它的作用是指定被请求的主机和端口号，它通常从 HTTP URL 中提取出来。</p>
<p>【实例】我们在浏览器中输入 <a href="https://www.cnblogs.com/liqingwen%EF%BC%8C%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8F%91%E9%80%81%E7%9A%84">https://www.cnblogs.com/liqingwen，浏览器发送的</a> HTTP 请求中就会包含 Host 的 Header，例如 Host: <a href="http://www.cnblogs.com">www.cnblogs.com</a> 。 此处使用了默认端口 80。</p>
<p>如果指定了端口号，例如我们在浏览器中输入 <a href="http://www.669.icu:15375">http://www.669.icu:15375</a>，则 Header 变为 <code>Host: www.669.icu:15375</code></p>
<h1>4.3 Fiddler 查看 HTTP 响应 Header</h1>
<p>如图所示，单击“Inspectors tab”，在 HTTP 响应中单击“ Headers“能看到 Fiddler 对 HTTP 响应 Header 进行了分类。</p>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210102204308441.png" alt="image-20210102204308441"></p>
<h1>4.4 Fiddler 查看和复制 Header</h1>
<p>在 Inspectors 下面的 Headers tab 窗口里，我们可以很方便地查看或者复制 Header</p>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210102204350862.png" alt="image-20210102204350862"></p>
<h1>参考</h1>
<ul>
<li>《HTTP 抓包实战》</li>
</ul>
]]></content>
      <categories>
        <category>《HTTP 抓包实战》</category>
      </categories>
      <tags>
        <tag>http</tag>
        <tag>抓包</tag>
      </tags>
  </entry>
  <entry>
    <title>09 Fiddler 前端快速调试</title>
    <url>/2020/01/09/HTTP%20%E6%8A%93%E5%8C%85%E5%AE%9E%E6%88%98/09%20Fiddler%20%E5%89%8D%E7%AB%AF%E5%BF%AB%E9%80%9F%E8%B0%83%E8%AF%95/</url>
    <content><![CDATA[<p>Fiddler 中的 Auto Responder 功能可以把要调试的文件保存到本地进行调试，这大大减少了在线调试的困难。</p>
<p>测试工程师在做测试的时候，也需要服务器返回 一 些特殊的数据来做测试，使用 AutoResponder 功能来伪造测试数据，能大大减少测试工程师的工作量。</p>
<a id="more"></a>
<h1>9.1 如何在服务器上调试 JavaScript 文件</h1>
<p>前端开发工程师在日常工作中，经常会发现服务器上某个 css 文件或者 JavaScript 文件有问题 。</p>
<p>一般情况下，遇到这种情况时是这么做的：前端工程师先在本地修改好 JS 文件，这个时候他并不能确保他的修改是对的：他需要把 JS 文件部署到测试环境上，然后测试和验证；如果修改得不对，还需要重新修改、 重新部署。</p>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210109015812145.png" alt="image-20210109015812145"></p>
<p>缺点：</p>
<ol>
<li>部署非常浪费时间</li>
<li>容易影响测试环境或者开发环境的稳定性</li>
<li>可能需要大量的修改和验证，非常繁琐，非常浪费时间</li>
</ol>
<h1>9.2 Fiddler AutoResponder 的工作原理</h1>
<p>使用 Fiddler 可以替换自动返回的一个伪造的 HTTP 响应 。这跟之前介绍的下断点修改 HTTP 响应差不多 ，只不过 AutoResponder 是自动的，操作更方便，</p>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210109020127382.png" alt="image-20210109020127382"></p>
<h1>9.3 Fiddler 在线调试 JavaScript 文件</h1>
<p>线上环境有一个 JavaScript 文件出了问题，我们可以利用 Fiddler 来快速调试，具体操作步骤如下（整个步骤需要重试） 。</p>
<ol>
<li>网页 <a href="http://www.cnblogs.com/liqingwen/">http://www.cnblogs.com/liqingwen/</a> 使用 了 一个 JS 文件 TankPageFooter.js ，先把这个 JS 文件保存在本地。</li>
<li>编辑本地的 JavaScript 文件，将其中的代码改为：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$().ready()</span><br><span class="line">&#123;</span><br><span class="line">	$(&#39;.site-title&quot;).html(&quot;update by Fiddler AutoResponder!!!!! tank xiao&quot;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>启动 Fiddler，在浏览器中打开 <a href="http://www.cnblogs.com/liqingwen/%EF%BC%8C%E6%88%91%E4%BB%AC%E5%8F%AF%E4%BB%A5%E7%9C%8B%E5%88%B0Fiddler">http://www.cnblogs.com/liqingwen/，我们可以看到Fiddler</a> 抓到 了 这个<br>
JavaScript 的 HTTP 请求，应该是：<a href="http://files.cnblogs.com/liqingwen/TankPageFooter.js">http://files.cnblogs.com/liqingwen/TankPageFooter.js</a></li>
<li>在 Fiddler 中，找到 <a href="http://files.cnblogs.com/files/liqingwen2/TankPageFooter.js">http://files.cnblogs.com/files/liqingwen2/TankPageFooter.js</a> 这个请求，然后将其拖曳到 AutoResponder 中。</li>
</ol>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210109021832668.png" alt="image-20210109021832668"></p>
<ol start="5">
<li>
<p>在 RuleEditor 中单击“ Find a file . . . ”，选择本地 JavaScript 文件的路径。</p>
</li>
<li>
<p>选中“ Enable rules” ，激活规则。选中“ Unmatched requests passthrough”，放行不匹配的 HTTP 请求</p>
</li>
<li>
<p>单击“ Save“按钮</p>
</li>
<li>
<p>你只需要修改本地机器上的文件，然后刷新浏览器，这样你就能看到效果了</p>
</li>
</ol>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210109022240661.png" alt="image-20210109022240661"></p>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210109022255392.png" alt="image-20210109022255392"></p>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210109022312418.png" alt="image-20210109022312418"></p>
<h1>9.4 浪漫的程序员</h1>
<p>Fiddler AutoResponder。</p>
<h1>9.5 替换网页中的图片</h1>
<p>Fiddler 替换掉网页中的图片。</p>
<ol>
<li>启动 Fiddler，打开浏览器访 问 <a href="https://blog.669.icu/">https://blog.669.icu/</a></li>
<li>在浏览器中把一张图片保存到本机中，命名为 fanguzai.jpg。</li>
</ol>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210109022506020.png" alt="image-20210109022506020"></p>
<ol start="3">
<li>
<p>用画图工具编辑 fanguzai.jpg 。</p>
</li>
<li>
<p>在 Fiddler 中，找到这个图片的 Sesssion，并且拖曳到 AutoResponder 中。</p>
</li>
<li>
<p>在 RuleEditor 中，单击“ Find a file … . ”，选择本地的 fanguzai.jpg 。 选中“ Enable rules ”，激活规则，选中“ Unmatched requests passthrough ”，并且单击“ Save ＂按钮。</p>
</li>
</ol>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210109022559935.png" alt="image-20210109022559935"></p>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210109022613710.png" alt="image-20210109022613710"></p>
<ol start="6">
<li>刷新浏览器，可以看到网页中的图片己经被替换了</li>
</ol>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210109022638712.png" alt="image-20210109022638712"></p>
<h1>参考</h1>
<ul>
<li>《HTTP抓包实战》</li>
</ul>
]]></content>
      <categories>
        <category>《HTTP 抓包实战》</category>
      </categories>
      <tags>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title>10 Fiddler 的 Script 用法</title>
    <url>/2020/01/09/HTTP%20%E6%8A%93%E5%8C%85%E5%AE%9E%E6%88%98/10%20Fiddler%20%E7%9A%84%20Script%20%E7%94%A8%E6%B3%95/</url>
    <content><![CDATA[<p>Fiddler Script 是一个可以自动修改 HTTP 请求和 HTTP 响应的脚本文件，不用手动地去下“断点”来修改。<br>
Fiddler Script 属于 Fiddler 的高级内容，它可以让 Fiddler 的扩展性更好 ，功能更加强大。</p>
<a id="more"></a>
<h1>10.1 Fiddler Script 介绍</h1>
<p>在大多数情况下 ， 通过 Fiddler 默认菜单的功能就可以基本满足开发者的调试需求。这里是针对复杂的场景。</p>
<p>Fiddler Seript 的本质其实是用 <a href="http://JScript.NET">JScript.NET</a> 语言写的一个脚本文件 CustomRules.js，其语法类似于 C＃。</p>
<p>通过修改 CustomRules.js 可以很容易修改 HTTP 请求和 HTTP 响应，不用中断程序；利用它还可以针对不同的 URL 做特殊的处理 。</p>
<p>CustomRules.js 位于 ：<code>C:\Documents and Settings\[your user]\My Documents\Fiddler2\Scripts\CustomRules.js</code> 下。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 比如我的本地文件位置</span><br><span class="line">C:\Documents and Settings\wen\My Documents\Fiddler2\Scripts</span><br></pre></td></tr></table></figure>
<p>也可以在 Fiddler 中打开 CustomRules .js 文件， 启动 Fiddler，单击菜单 Rules -&gt; CustomizeRules …</p>
<p>Fiddler Script 的官方帮助文档的地址是：<a href="http://www.fiddlerbook.com/FiddlerIdev/ScriptSamples.asp">http://www.fiddlerbook.com/FiddlerIdev/ScriptSamples.asp</a></p>
<h1>10.2 Fiddler Script Editor</h1>
<p>目前最新版的 Fiddler 己经集成 了 Fiddler Script Editor 插件，不需要额外安装。</p>
<p>推荐使用 FiddlerScript Editor 来编辑。</p>
<p>Fiddler Script Editor 提供了语法高亮显示编译错误提示和智能提示的功能， 编辑起来很方便。</p>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210116200318807.png" alt="image-20210116200318807"></p>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210110135901525.png" alt="image-20210110135901525"></p>
<p>启动 Fiddler，单击菜单 Rules -&gt; Customize Rules …，如图 10-3 所示，可以打开 CustomRules.js 文件。</p>
<p>这三种方法都可 以用来编辑 CustomRules.js。</p>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210110140027259.png" alt="image-20210110140027259"></p>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210110140042075.png" alt="image-20210110140042075"></p>
<h1>10.3 CustomRules.js 中的主要方法</h1>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static function OnBeforeRequest(oSession: Session)</span><br></pre></td></tr></table></figure>
<p>OnBeforeRequest 函数在每次请求之前调用。在这个方法中修改 Request 的内容，我们用得最多</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static function OnBeforeResponse(oSession: Session)</span><br></pre></td></tr></table></figure>
<p>OnBeforeResponse 函数在每次响应之前调用，在这个方法中修改 Response 的内容。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static function OnExecAction(sParams: String[])</span><br></pre></td></tr></table></figure>
<p>这个方法中包含 Fiddler 命令。命令是在 Fiddler 界面中左下方的 QuickExec 中执行的。</p>
<h1>10.4 Fiddler 定制菜单</h1>
<p>Fiddler 可以模拟各种浏览器，可以通过单击菜单 Rules -&gt; User-Agents 下的子菜单来实现。</p>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210116200754614.png" alt="image-20210116200754614"></p>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210110140318489.png" alt="image-20210110140318489"></p>
<p>User-Agents 菜单中好像没有 Iphone 4S safari，我们现在定制一个。先在网上查询 iPhone 4S safari 的 user-Agents ，然后添加如下代码就可以了：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">RulesStringValue(23, &quot;Iphone 48 safari&quot;, &quot;Mozilla&#x2F;5.0 (iPhone; U; CPU iPhone OS 4_0 like Mac OS X; en-us) AppleWebKit&#x2F;532.9 (KHTML, like Gecko) Version&#x2F;4.0.5 Mobile&#x2F;8A293 Safari&#x2F;6531.22.7&quot;)</span><br></pre></td></tr></table></figure>
<p>保存脚本，重启 Fiddler 就可以看到菜单中多了个 Iphone 4s safari 。</p>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210116201542212.png" alt="image-20210116201542212"></p>
<p>可以把常用的操作都定义成一个菜单，这样用起来很方便。</p>
<h1>10.5 修改 Session 在 Fiddler 的显示样式</h1>
<p>有时候，找到自己想要的 HTTP 请求是需要靠眼力的，我们可以用 Script 设置一下颜色。</p>
<p>我们可以控制 Session 在 Fiddler 中显示的样式 。</p>
<p>把以下脚本放在 OnBeforeRequest(oSession: Session） 方法下，并且单击“ Save script” ，这样所有的 cnblogs 会话都会显示为红色 。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (oSession.HostnameIs(&quot;www.cnblogs.com&quot;)) &#123;</span><br><span class="line">	oSession[&quot;ui-color&quot;] &#x3D; &quot;red&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210116202211567.png" alt="image-20210116202211567"></p>
<p>保存后重新进行请求：</p>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210116202034372.png" alt="image-20210116202034372"></p>
<p>【注意】如果不生效，尝试重启 Fiddler</p>
<h1>10.6 修改 HTTP 请求</h1>
<p>如果要修改 HTTP 请求，代码应该放在 OnBeforeRequest(oSession: Session）方法下面。</p>
<p>我们可以修改 HTTP 请求中的任何数据 ，如 HOST 、Header、Cookie 等 。</p>
<h2 id="10-6-1-修改-HTTP-请求中的-Cookie">10.6.1 修改 HTTP 请求中的 Cookie</h2>
<p>Cookie 其实就是 HTTP 请求 中的一个 Header 。</p>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210110141109833.png" alt="image-20210110141109833"></p>
<h2 id="10-6-2-替换-HTTP-请求的-Host-地址">10.6.2 替换 HTTP 请求的 Host 地址</h2>
<p>我们最初发送给 A 站点的 HTTP 请求，都被 Fiddler 转发到 B 站点，而在浏览器中毫无感觉。测试或者 debug 过程中经常会有这种需求。</p>
<p>例如用 <a href="http://www.tank-demo.com">www.tank-demo.com</a> 替换 <a href="http://www.tank-dev.com">www.tank-dev.com</a>。</p>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210110141240408.png" alt="image-20210110141240408"></p>
<h2 id="10-6-3-修改-HTTP-请求中的-Header">10.6.3 修改 HTTP 请求中的 Header</h2>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210110141302787.png" alt="image-20210110141302787"></p>
<h2 id="10-6-4-修改-HTTP-请求中的-Body">10.6.4 修改 HTTP 请求中的 Body</h2>
<p>方法一 ：先把 Body 的字符串读取出来，修改后再塞回去。</p>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210110141347460.png" alt="image-20210110141347460"></p>
<p>方法二 ：也可以采用非常简单的方法，即直接替换 body 中的数据 。</p>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210110141423802.png" alt="image-20210110141423802"></p>
<h1>10.7 修改 HTTP 晌应</h1>
<p>在 Script 中修改 HTTP 响应的方法 ，代码应该放在 OnBeforeResponse(oSession: Session）方法下面 。</p>
<p>修改 HTTP 响应的方法和修改 HTTP 请求的方法差不多。</p>
<p>【实例】使用如下代码，修改博客园网页中的数据。</p>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210110141521627.png" alt="image-20210110141521627"></p>
<p>打开浏览器，输入 <a href="http://www.cnblogs.com/liqngwen/">www.cnblogs.com/liqngwen/</a></p>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210110141555817.png" alt="image-20210110141555817"></p>
<h1>10.8 读写 txt 文件</h1>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 导入命名空间</span><br><span class="line">import System.IO;</span><br></pre></td></tr></table></figure>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210110141647663.png" alt="image-20210110141647663"></p>
<h1>10.9 使用正则表达式</h1>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 导入命名空间</span><br><span class="line">import System.Text.RegularExpressions;</span><br></pre></td></tr></table></figure>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210110141729767.png" alt="image-20210110141729767"></p>
<h2 id="10-10-保存-Session">10.10 保存 Session</h2>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210110141748114.png" alt="image-20210110141748114"></p>
<h1>10.11 读取 Session ，并且使用 Fiddler 来发送</h1>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210110141810651.png" alt="image-20210110141810651"></p>
<h1>参考</h1>
<p>《HTTP抓包实战》</p>
<h1>修订</h1>
]]></content>
      <categories>
        <category>《HTTP 抓包实战》</category>
      </categories>
      <tags>
        <tag>http</tag>
        <tag>抓包</tag>
      </tags>
  </entry>
  <entry>
    <title>11 深入理解 Cookie 机制</title>
    <url>/2020/01/09/HTTP%20%E6%8A%93%E5%8C%85%E5%AE%9E%E6%88%98/11%20%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%20Cookie%20%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<p>它是 Web 开发中 一个很重要的客户端数据来源，而且它可以实现扩展性很好的会话状态，并且通过使用 Fiddler 来捕获 Web 登录时的 HTTP 数据包来了解登录的原理 。</p>
<a id="more"></a>
<h1>11.1 HTTP 协议是无状态的</h1>
<p>对于浏览的每一次请求，服务器都会独立处理，不与之前或之后的请求发生关联。</p>
<p>即使是同一个浏览器发送 了 3 个请求，服务器也会独立处理这 3 个请求 ，服务器并不知道这 3 个请求是来自同 一个浏览器 。</p>
<p>服务器需要识别浏览器请求，就必须弄清楚浏览器的请求状态。既然 HTTP 协议是无状态的，那就让服务器和浏览器共同维护一个状态，这就是会话机制。</p>
<h1>11.2 会话机制</h1>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210110143618461.png" alt="image-20210110143618461"></p>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210110143631497.png" alt="image-20210110143631497"></p>
<ol>
<li>浏览器第一次请求服务器时，服务器创建一个会话，并将会话的 id 作为响应的一部分发送给浏览器</li>
<li>浏览器存储会话 id，并在后续第二次和第三次请求中带上会话 id。服务器取得请求中的会话 id 就知道是不是同一个用户了</li>
</ol>
<p>这样一来，后续请求与第一次请求就产生了关联。</p>
<h1>11.3 Cookie 机制</h1>
<p>服务器在内存中保存会话对象。浏览器可以使用 Cookie 机制保存会话 id。</p>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210110143758947.png" alt="image-20210110143758947"></p>
<p>Cookie 机制是一种会话机制。Cookie 是浏览器用来存储少量数据的一种机制，数据以“key=value ”形式存储，浏览器发送 HTTP 请求时 ，自动附带 cookie 信息。</p>
<h1>11.4 Cookie 是什么</h1>
<p>Cookie 是一小段文本信息，伴随着用户请求和页面在浏览器和 Web 服务器之间传递。</p>
<p>Cookie 是一种 HTTP Header，以“key=value”的形式组成，比如 ip_country=CN。</p>
<p>两个 Cookie 之间用分号隔开，比如 ip_country=CN; mbox=check#true#1499311989。</p>
<p>浏览器把 Cookie 通过 HTTP 请求中的 Header，比如“ Cookie: ip_country=CN“发送给 Web 服务器。Web 服务器通过 HTTP 响应中的 Header，比如“ Set-Cookie: ip_country=CN ”，把 Cookie 发送给浏览器 。</p>
<p>使用 Fiddler 可以清楚地看到 Cookie 在浏览器和服务器之间传递的过程。Fiddler 工具中可以清晰地看到 HTTP 请求中的 Cookie 和 HTTP 响应中的 Cookie 。</p>
<p>【实例】启动 Fiddler，打开浏览器访问一些购物网站</p>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210110144132912.png" alt="image-20210110144132912"></p>
<h1>11.5 Cookie 的作用</h1>
<p>Cookie 最主要的作用是用来做用户认证，还可以用于保存用户的一些其他信息。</p>
<p>Cookie 也可以用于互联网精准广告定向技术，比如用户浏览了某些商品，就可以用 Cookie 将其记录下来，对网民所有的上网行为进行个性化的深度分析：按广告主需求锁定目标受众，进行一对一传播，提供多通道投放，按照效果付费。</p>
<h1>11.6 抓包观察上海科技馆网站的登录</h1>
<p>我们通过 Fiddler 来抓包观察上海科技馆网站的登录，来理解登录的过程和 Cookie 机制。</p>
<p>第一步：启动 Fiddler，启动浏览器，打开 <a href="http://piaoweb.sstm.org.cn/%EF%BC%9B%E8%BE%93%E5%85%A5%E7%94%A8">http://piaoweb.sstm.org.cn/；输入用</a> 户名和密码 ，单击登录（请读者自己注册账号）。</p>
<p>抓包后可以看到浏览器把用户名和密码发送给了 Web 服务器</p>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210116203154194.png" alt="image-20210116203154194"></p>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210110144510162.png" alt="image-20210110144510162"></p>
<p>Web 服务器会验证用户名和密码的正确性，然后通过“ Set-Cookie ＂ 给浏览器发送 3 个 Cookie，其中一个是用来保存登录信息的 。</p>
<p>第二步：在浏览器中打开“用户中心”：<a href="http://piaoweb.sstm.org.cn/user/center/orderlist%E3%80%82">http://piaoweb.sstm.org.cn/user/center/orderlist。</a></p>
<p>抓包后可以看到，HTTP 请求中会带上 Cookie（即在上一步中 Web 服务器返回的 Cookie），这样 Web 服务器就认为浏览器是登录状态。</p>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210110144742949.png" alt="image-20210110144742949"></p>
<h1>11.7 Cookie 的属性</h1>
<p>从 Fiddler 的抓包中，我们可以看到 Web 服务器返回了下面这一段数据给浏览器。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Set-Cookie: cookie_user_token&#x3D;C5CBD6FBDODAOEE4B5DC36E7075D8CDA; Expires&#x3D;Thu,06-Jul-2017 09:17:46 GMT;Path&#x3D;&#x2F;;HttpOnly</span><br></pre></td></tr></table></figure>
<ol>
<li>
<p>Expires 属性：Expires 的值是一个时间，代表过期时间 。过了这个时间， 该 Cookie 就失效了。</p>
<p>如果不指定 Expire time ， 表示关闭浏览器/页面的时候 ， 此 Cookie 就应该被浏览器删除了。</p>
</li>
<li>
<p>Path 属性：表示 Cookie 所属 的路径，<a href="http://asp.net">asp.net</a> 默认为“／”，就是根目录 。在同一个服务器上的目录如下： ／test／ 、 ／test/cd人／test/dd/ 。 现假设一个 Cookiel 的 path 为 /test/ , Cookie2 的 path 为 /test/cd/，那么 test 下的所有页面都可以访问到 Cookiel ，而／test/dd/的子页面不能访问 cookie2 。这是因为 Cookie 只能让其 path 路径下的页面访问。</p>
</li>
<li>
<p>HttpOnly 属性：这是个关于安全方面的属性，将一个 Cookie 设置为 HttpOnly 后 ，通过 Javascript 脚本将无法读取到 Cookie 信息，这能有效地防止黑客用 xss 发起攻击</p>
</li>
</ol>
<p>【注意】一般来说，跟登录相关的 Cookie 必须设置为 HttpOnly。</p>
<h1>11.8 Cookie 的分类</h1>
<p>我们可以大致把 Cookie 分为 2 类：会话 Cookie 和持久 Cookie。</p>
<p>会话 Cookie 是一种临时的 cookie，它记录了用户访问站点时的设置和偏好；关闭浏览器，会话 Cookie 就被删除了。</p>
<p>持久 Cookie 存储在硬盘上 ，不管浏览器退出或者计算机重启，持久 cookie 都继续存在。持久 Cookie 有过期时间。</p>
<h1>11.9 Cookie 保存在哪里</h1>
<p>Cookie 是存在硬盘上的，IE 存 Cookie 的地方和 Firefox 存 Cookie 的地方不一样 。 不同的操作系统存 Cookie 的地方也可能不一样。</p>
<p>不同的浏览器会在各自的独立空间存放 Cookie ，互不干涉。</p>
<p>以 Windows7 、IE8 为例，Cookie 的存放路径为  <code>C:\Users\xiaoj\AppData\Local\Microso\Windows\Temporary Internet Files</code>。</p>
<p>【注意】缓存文件和 cookie 文件是存在一起的，都在这个目录下。</p>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210110145719423.png" alt="image-20210110145719423"></p>
<p>不同的网站会有不同的 Cookie 文件：</p>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210110145740702.png" alt="image-20210110145740702">#</p>
<h1>11.10 使用和禁用 Cookie</h1>
<p>可以在 IE 浏览器中设置禁用 Cookie 。 打开控制面板中的 Internet 选项，选择隐私选项卡。</p>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210110145843541.png" alt="image-20210110145843541"></p>
<h1>11.11 网站自动登录的原理</h1>
<p>很多网站都有自动登录的功能 ， 我们以 “博客园自动登录”为例来说明 Cookie 是如何传递的。</p>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210110145923058.png" alt="image-20210110145923058"></p>
<p>在登录页面输入用户名、密码，选择保存密码单击登录（这时候，其实在你的机器上己保存好了登录的 Cookie ，可以按照上节介绍的方法去你的计算机上找一下博客园的（Cookie）。</p>
<p>我们下次访问博客园的流程如下：</p>
<ol>
<li>用户打开 IE 浏览器，在地址栏输入 <a href="http://www.cnblogs.com">http://www.cnblogs.com</a></li>
<li>IE 首先会在硬盘中查找关于 <a href="http://cnblogs.com">cnblogs.com</a> 的 Cookie，然后把 Cookie 放到 HTTP Request 中，再把 Request 发给 Web 服务器</li>
<li>Web 服务器返回博客园首页，这时你会看到自己已经登录了。</li>
</ol>
<h1>11.12 Cookie 和文件缓存的区别</h1>
<p>【提示】很多人会把 Cookie 和文件缓存弄混淆，这是两个完全不一样的东西。唯一的相同之处可能是它们俩都存在硬盘上，而且存在同一个文件夹下 。</p>
<p>我们可以在 IE 中分别选择删除 Cookie 和缓存文件。</p>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210110150156545.png" alt="image-20210110150156545"></p>
<h1>11.13 Cookie 泄露隐私</h1>
<p>很多不法公司利用 Cookie 跟踪并采集用户的个人信息，并转卖给网络广告商，形成了 一条窃取用户信息的灰色产业链。</p>
<h1>参考</h1>
<p>《HTTP抓包实战》</p>
<h1>修订</h1>
]]></content>
      <categories>
        <category>《HTTP 抓包实战》</category>
      </categories>
      <tags>
        <tag>http</tag>
        <tag>抓包</tag>
      </tags>
  </entry>
  <entry>
    <title>12 Fiddler 实现 Cookie 劫持攻击</title>
    <url>/2020/01/09/HTTP%20%E6%8A%93%E5%8C%85%E5%AE%9E%E6%88%98/12%20Fiddler%20%E5%AE%9E%E7%8E%B0%20Cookie%20%E5%8A%AB%E6%8C%81%E6%94%BB%E5%87%BB/</url>
    <content><![CDATA[<p>Cookie 用于维持会话 ，如果这个 Cookie 被攻击者窃取的话，会发生什么呢？Cookie 被窃取相当于会话被劫持。攻击者劫持会话就等于合法登录了他人的账户 ，可以浏览大部分用户资源。</p>
<a id="more"></a>
<h1>12.1 截获 Cookie 冒充别人身份</h1>
<p>Cookie 是很重要的，其用于识别用户身份，假如攻击者截获了别人的 Cookie，是否可以冒充他人的身份登录呢？当然可以。这种黑客技术叫 Cookie 欺骗或者会话劫持。</p>
<p>利用 Cookie 欺骗，不需要知道用户名和密码就可 以直接登录进行操作，从而获取你的信息，修改你的资料，甚至挪用你的资金，这里非常危险的。</p>
<p>通常有两种方法可以截获他人的 Cookie</p>
<ol>
<li>通过跨站脚本攻击（XSS）获取他人的 Cookie</li>
<li>想办法获取别人电脑上保存的 Cookie 文件</li>
</ol>
<h1>12.2 Cookie 劫持的原理</h1>
<p>第一步：黑客通过某种手段，比如 xss，得到了 Cookie。</p>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210110150648840.png" alt="image-20210110150648840"></p>
<p>第二步：黑客使用 Cookie，在没有用户名和密码的情况下直接冒充用户的身份登录。</p>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210110150738798.png" alt="image-20210110150738798"></p>
<h1>12.3 Cookie 劫持实例介绍</h1>
<p>我们通过豆瓣网登录实例来演示 Cookie 劫持过程，具体步骤：</p>
<ol>
<li>找到登录的 Cookie 。具体做法是在计算机 A 上登录豆瓣网后，用 Fiddler 抓包，找到跟登录相关的 Cookie ，并把 Cookie 发给计算机 B</li>
<li>植入 Cookie。具体做法是在计算机 B 上，利用 Fiddler Script 把 Cookie 植入浏览器中，这样计算机 B 不需要用户名和密码，就可以直接登录了。</li>
</ol>
<h2 id="12-3-1-找到登录的-Cookie">12.3.1 找到登录的 Cookie</h2>
<p>首先，我们需要使用 Fiddler 找到跟登录相关的 Cookie：</p>
<ol>
<li>打开豆瓣网 <a href="http://www.douban.com">www.douban.com</a>，用账号和密码登录</li>
<li>启动 Fiddler，在豆瓣网中单击右上角的用户名，在菜单栏中单击“账号管理“，就跳转到了这个页面：<a href="https://www.douban.com/accounts/%EF%BC%8C%E6%8A%93%E5%88%B0%E7%9A%84%E5%8C%85">https://www.douban.com/accounts/，抓到的包</a></li>
</ol>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210110151153765.png" alt="image-20210110151153765"></p>
<ol start="3">
<li>在 Fiddler 中选择 <a href="https://www.douban.com/accounts/">https://www.douban.com/accounts/</a> 这个 Session，然后用鼠标右键选择 Replay-&gt; Reissue and Edit。在 Raw 选项卡下，找到一个名叫 dbc12 的 Cookie，比如我这里的是：dbc12=&quot;163572032:csU04lkxRDg＂；删除这个 dbcl2 的Cookie ，然后单击“ Run to Completion“放行。</li>
</ol>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210110151514179.png" alt="image-20210110151514179"></p>
<ol start="4">
<li>我们可以发现跳转到 了登录页面。这说明 dbcl2 这个 Cookie 是跟登录相关的，将其删除后就处于未登录状态，Web 服务器会返回 302 状态码，会自动重定向到登录界面。</li>
</ol>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210110151557939.png" alt="image-20210110151557939"></p>
<h1>12.3.2 浏览器中植入 Cookie</h1>
<p>我们得到了登录相关的 Cookie，dbcl2＝“ 163572032:csU041kxRDg“，只需要把这个 Cookie 植入浏览器中，就可以直接登录该账户进行操作了 。</p>
<p>之前的章节中我们讲解过 Fiddler Script 的用法，Fiddler Script 可以修改任何 HTTP 请求和 HTTP 响应，当然也可以很方便地修改 Cookie。</p>
<p>我们可以找一台新机器，在 Fiddler Script 中的 OnBeforeRequest 函数中添加如下语句</p>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210110151853723.png" alt="image-20210110151853723"></p>
<p>打开 一个浏览器，访问豆瓣网，我们可以 发现自己己处于 登录状态了。</p>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210110151921467.png" alt="image-20210110151921467"></p>
<h1>12.4 网站退出的作用</h1>
<p>Cookie 是非常重要的。网站登录后，都会有一个退出链接，网站退出是明确地告诉服务器立即删除服务器端的 Session 对象，这样客户端登录的 Cookie 就失效了。如果用户登录某个网站，然后离开的 时候直接关闭浏览器，那么登录的 Cookie 还在，存在被冒用的风险。保险的办法是单击退出而不是直接关闭浏览器。</p>
<h1>参考</h1>
<p>《HTTP抓包实战》</p>
<h1>修订</h1>
]]></content>
      <categories>
        <category>《HTTP 抓包实战》</category>
      </categories>
      <tags>
        <tag>http</tag>
        <tag>抓包</tag>
      </tags>
  </entry>
  <entry>
    <title>13 HTTP 基本认证</title>
    <url>/2020/01/09/HTTP%20%E6%8A%93%E5%8C%85%E5%AE%9E%E6%88%98/13%20HTTP%20%E5%9F%BA%E6%9C%AC%E8%AE%A4%E8%AF%81/</url>
    <content><![CDATA[<p>HTTP 协议是无状态的，浏览器和 Web 服务器之间可以通过 Cookie 来识别身份 。一些桌面应用程序（比如新浪桌面客户端、OneDrive 客户端和 Dropbox 客户端）跟 Web 服务器之间是如何识别身份呢？</p>
<p>HTTP 协议中还有两种认证方式，分别是<strong>基本认证</strong>和<strong>摘要认证</strong> 。认证就是客户端要给服务器出示一些自己的身份证明，来证明自己是谁，一旦服务器知道了客户端 的身份，就可以判定客户端可以进行访问了。通常是通过提供用户名和密码来进行认证的。</p>
<a id="more"></a>
<h1>13.1 什么是 HTTP 基本认证</h1>
<p>一些网站和 Web 服务使用的是 HTTP 基本认证。有些桌面应用程序也通过 HTTP 协议跟 Web 服务器交互，桌面应用程序一般不会使用 Cookie，而是把“用户名 + 冒号 + 密码”用 Base64 编码放在 HTTP 请求中的 <code>Header  Authorization</code> 中发送给服务端，这种方式叫 HTTP 基本认证（Basic Authentication） 。</p>
<p>在基本认证中， Web 服务器可以拒绝一个事物，要求客户端提供有效的用户名和密码。服务器会返回 401 状态码来初始化认证质询，并用 WWW-Authenticate 响应首部指定要访问的安全域 。浏览器收到质询肘，会打开一个对话框，请求用户输入用户名和密码，然后将用户名和密码用 Base64 编码，再用 Authorization 请求首部发送给服务器。</p>
<h2 id="13-1-1-路由器管理页面使用基本认证">13.1.1 路由器管理页面使用基本认证</h2>
<p>我们普通家庭里都会使用路由器，路由器的管理页面使用的就是基本认证，我们通过这个实例来理解基本认证的过程。</p>
<ol>
<li>找出路由器的 IP 地址，在 CMD 中输入 ipconfig 命令能知道路由器的 IP 地址，比如路由器的 IP 地址是 10.0.0.1</li>
</ol>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210110152823622.png" alt="image-20210110152823622"></p>
<ol start="2">
<li>启动 Fiddler，打开浏览器，输入 <a href="http://10.0.0.1">http://10.0.0.1</a> ，可以打开一个网页，网页会弹出对话框，要求用户输入用户名和密码。</li>
</ol>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210110152929555.png" alt="image-20210110152929555"></p>
<ol start="3">
<li>
<p>路由器用户名/密码是 admin/password。在对话框中输入用户名 admin 和密码 password2。因为密码错误，所以认证不会通过，服务器会返回 401 状态码。</p>
<p>在 HTTP 请求中可以看到有个 Authorization:Basic YWRtaW46cGFzc3dvcmQy。这是因为浏览器把“用户名＋冒号＋密码”用 Base64 编码了。例如 admin:password2 被编码后，就变成了 YWRtaW46cGFzc3dvcmQy。</p>
</li>
</ol>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210110153407821.png" alt="image-20210110153407821"></p>
<p>使用 Fiddler 中的 Auth 选项卡，可以方便地看到用户名和密码，以及编码后的字符串。</p>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210110153438278.png" alt="image-20210110153438278"></p>
<ol start="4">
<li>输入正确的用户名和密码（admin/password），认证通过，服务器返回 200 状态码给浏览器客户端</li>
</ol>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210110153526699.png" alt="image-20210110153526699"></p>
<p>这时就可以正常打开路由器的管理界面：</p>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210110153549259.png" alt="image-20210110153549259"></p>
<h2 id="13-1-2-HTTP-基本认证的优点">13.1.2 HTTP 基本认证的优点</h2>
<p>HTTP 基本认证简单明了，Restful API 就经常使用基本认证。</p>
<h2 id="13-1-3-HTTP-基本认证的缺点">13.1.3 HTTP 基本认证的缺点</h2>
<p>把 “用户名＋冒号＋密码”用 Base64 编码后的字符串虽然用肉眼看不出来，但用程序很容易解码，所以不能用 HTTP 在网络上传输。</p>
<p>【注意】一定要用 HTTPS 传输，因为 HTTPS 是加密的，稍微安全一点。</p>
<ol>
<li>HTTP 协议是无状态的，同一个客户端对服务器的每个请求都要求认证。</li>
<li>基本认证会通过网络发送用户名和密码，这些用户名和密码以 Base64 编码。Base64 编码是一种可逆编码，非常容易破解，所以基本认证相当于以明文的方式传输用户名和密码，非常容易被第三方拦截</li>
<li>使用基本认证登录后，除非关闭浏览器或者清除历史记录，否则将无法登出。</li>
<li>无法防止重放攻击。即使基本认证的密码是经过加密传输的，第三方仍然可以捕获被修改过的用户名和密码，并将修改过的用户名和密码反复多 次地重放给原始服务器，以获得对服务器的访问权 ， 基本认证没有什么措施可以防止这些重放攻击。</li>
</ol>
<h2 id="13-1-4-使用-TextWizard-工具">13.1.4 使用 TextWizard 工具</h2>
<p>单击 Fiddler 工具栏中 的 TextWizard ，可以调出 一个小工具 TextWizard 来进行 Base64 编码和解码。</p>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210116204937697.png" alt="image-20210116204937697"></p>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210110154249736.png" alt="image-20210110154249736"></p>
<h2 id="13-1-5-客户端的使用">13.1.5 客户端的使用</h2>
<p>客户端跟“ 使用基本认证的网站”交互非常简单，把用户名、密码加在 Authorization header 中就可以了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">string url &#x3D; &quot;https:&#x2F;&#x2F;testsite&quot;;</span><br><span class="line">HttpWebRequest req &#x3D; (HttpWebRequest)WebRequest.Create(url);</span><br><span class="line">NetworkCredential nc &#x3D;new NetworkCredential(&quot;username&quot;, &quot;password&quot;);</span><br><span class="line">req.Credentials &#x3D; nc ;</span><br></pre></td></tr></table></figure>
<p>Linux 下的 curl 如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl -u username:password https:&#x2F;&#x2F;testsite&#x2F;</span><br></pre></td></tr></table></figure>
<h1>13.2 摘要认证</h1>
<p>摘要认证是针对基本认证存在的诸多问题而进行改良的方案。摘要认证是另外一种 HTTP 认证协议，它试图修复基本认证的严重缺陷，进行如下改进。</p>
<ol>
<li>通过传递用户名、密码等计算出来的摘要来解决以明文方式在网络上发送密码的问题</li>
<li>通过服务器产生随机数 nonce 的方式防止恶意用户捕获并重放认证的握手过程</li>
<li>通过客户端产生随机数 enonce 的方式支持客户 端对服务器的认证</li>
<li>通过对内容也加入摘要计算的方式，可以有选择地防止对报文内容的篡改</li>
</ol>
<h1>参考</h1>
<p>《HTTP 抓包实战》</p>
]]></content>
      <categories>
        <category>《HTTP 抓包实战》</category>
      </categories>
      <tags>
        <tag>http</tag>
        <tag>抓包</tag>
      </tags>
  </entry>
  <entry>
    <title>14 Fiddler 手机抓包</title>
    <url>/2020/01/09/HTTP%20%E6%8A%93%E5%8C%85%E5%AE%9E%E6%88%98/14%20Fiddler%20%E6%89%8B%E6%9C%BA%E6%8A%93%E5%8C%85/</url>
    <content><![CDATA[<p>Fiddler 不但能截获各种浏览器发出的 HTTP 请求，也可以截获各种智能手机发出的 HTTP/HTTPS 请求 。</p>
<p>Fiddler 能捕获 iOS 设备发出的请求，比如 iPhone、iPad 和 MacBook 等苹果设备 。同理，其也可以截获均由 Android 和 Windows Phone 等设备发出的 HTTP/HTTPS 请求。</p>
<a id="more"></a>
<h1>14.1 环境准备</h1>
<p>Fiddler 如果想要实现手机抓包：</p>
<ol>
<li>电脑上安装有 Fiddler 抓包工具</li>
<li>安装有 Fiddler 的电脑必须跟手机处在同 一个网络里</li>
<li>在 Fiddler 中设置好捕获 HTTPS</li>
</ol>
<h1>14.2 Fiddler 截获手机原理图</h1>
<p>Fiddler 作为代理服务器，可以接收远程机器发来的 HTTP/HTTPS 协议的数据包，并且将其转发到 Web 服务器。</p>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210110155515388.png" alt="image-20210110155515388"></p>
<h1>14.3 截获手机发出的 HTTP 包有什么作用</h1>
<p>用处一：APP 开发人员利用 Fiddler 可以截获手机发出的 HTTP 包，从而调试 APP 程序。</p>
<p>用处二：软件测试人员可以用其来测试智能手机上的软件，做接口测试或者安全测试。</p>
<p>用处三：截获了 HTTP/HTTPS 后，可以下断点修改 HTTP 请求和 HTTP 响应。</p>
<h1>14.4 手机抓包</h1>
<h2 id="14-4-1-配置-Fiddler-允许“远程连接”">14.4.1 配置 Fiddler 允许“远程连接”</h2>
<p>启动 Fiddler ，单击菜单栏中 Tools-&gt;Fiddler Options-&gt;Connections ，选中“ Allow remote computers to connect ”</p>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210110155757123.png" alt="image-20210110155757123"></p>
<p>选中后就表示允许远程机器把 HTTP/HTTPS 请求发送到 Fiddler 上来（配置完后记得要重启 Fiddler ）。同时，我们还能看到 Fiddler 的工作端口号是 8888。</p>
<h1>14.4.2 获取 Fiddler 所在机器的 IP 地址</h1>
<p>查看电脑的 IP 地址，按快捷键 [Windows+R］，调出运行窗口。输入 CMD，可以打开 CMD 命令行工具；输入命令 <code>ipconfig</code>，可以找到 IP 地址。</p>
<p>一个电脑可能有多个网卡，注意要找到真正 的 IP 地址，例如某 IP 地址是 10.0.0.1.1。</p>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210110155959350.png" alt="image-20210110155959350"></p>
<p>或者在 Fiddler 中，将鼠标放在右上方的“online”图标上，提示信息中也能看到 IP 地址。</p>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210116205509272.png" alt="image-20210116205509272"></p>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210110160032600.png" alt="image-20210110160032600"></p>
<h1>14.4.3 手机上设置代理服务器</h1>
<p>以华为手机为例进行讲解，其他品牌的手机操作方法与此差不多。具体操作步骤如下：</p>
<ol>
<li>打开手机中的设置 -&gt; WLAN，找到手机当前连接的 Wi-Fi：</li>
</ol>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210110160157884.png" alt="image-20210110160157884"></p>
<ol start="2">
<li>将代理改为手动，服务器主机名为 Fiddler 所在电脑的 IP 地址， 服务器端口为 8888</li>
</ol>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210110160228074.png" alt="image-20210110160228074"></p>
<ol start="3">
<li>单击“连接”就可以设置成功</li>
</ol>
<h1>14.4.4 测试 Fiddler 捕获手机发出的 HTTP</h1>
<p>打开手机上的浏览器，在浏览器中输入 <a href="http://www.163.com">www.163.com</a>。163 网站用的是 HTTP 协议而不是 HTTPS 协议，查看 Fiddler 是否捕获到了 HTTP 数据包。</p>
<p>打开手机上的 APP，在 APP 中进行 一 些操作，查看 Fiddler 是否能捕获到 HTTP 数据包。</p>
<p>如果抓不到 HTTP 的包，很可能是 Windows 防火墙的问题，到控制面板中关闭防火墙后再试试。</p>
<h1>14.4.5 捕获手机上的 HTTPS</h1>
<p>如果只是抓取手机上 APP 或者浏览器发出的 HTTP 请求，则不需要安装证书， 直接就能抓到。</p>
<p>如果需要捕获 HTTPS 请求，则必须把 Fiddler 证书安装到手机上 。</p>
<h1>14.4.6 Apple 设备需要使用插件制作新证书</h1>
<p>如果要对 Apple 设备进行抓包，则需要重新做证书，某些 Android 可能也需要重新做证书。</p>
<p>Fiddler 默认的证书是基于命令行工具 makecert.exe，几乎所有的 Windows 客户端都接受该工具生产的证书。但是 Apple IOS 设备（ iPhone 、iPad ）和少部分 Android 要求根证书和服务器证书包含 makecert.exe 生产的证书中所没有的其他元数据。为了兼容这些设备，需要下载 Fiddler 插件“ CertMaker for IOS and Android ”。</p>
<p>Certificate Maker 的下载地址是 <a href="http://www.telerik.com/fiddler/add-ons">http://www.telerik.com/fiddler/add-ons</a></p>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210110161429604.png" alt="image-20210110161429604"></p>
<h2 id="14-4-7-iOS-设备安装证书方法">14.4.7 iOS 设备安装证书方法</h2>
<ol>
<li>打开 iOS 手机的 Safari 浏览器，输入 <a href="http://hostip:8888">http://hostip:8888</a>，hostip 就是 Fiddler 所在的<br>
计算机上的 IP。在打开的网页中，单击 “ FiddlerRoot certificate ”，单击“ 允许”，下载证书。</li>
</ol>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210110161837508.png" alt="image-20210110161837508"></p>
<ol start="2">
<li>单击“ 安装”，安装证书</li>
</ol>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210110161902184.png" alt="image-20210110161902184"></p>
<h2 id="14-4-8-Android-设备安装证书方法一">14.4.8 Android 设备安装证书方法一</h2>
<p>打开手机的浏览器，输入 <a href="http://hostip:8888">http://hostip:8888</a>，hostip 就是 Fiddler 所在的计算机上的 IP。在打开的网页上单击“ FiddlerRoot certificate“下载证书。</p>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210110162036557.png" alt="image-20210110162036557"></p>
<p>在安装证书的界面，给证书取一个名字，然后单击“确定”，系统会提示证书安装成功。</p>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210110162104346.png" alt="image-20210110162104346"></p>
<p>证书安装成功后，如果你的手机系统没有设置密码或者锁屏图案，则系统会提示你设置锁屏图案或者密码。</p>
<p>当然这种方法可能会安装失败。如有的手机无法按这种方式安装证书并提示“无法安装该证书，因为无法读取证书文件文件。这时可以使用下面的方法来安装证书。</p>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210110162202778.png" alt="image-20210110162202778"></p>
<h2 id="14-4-9-Android-设备安装证书方法二">14.4.9 Android 设备安装证书方法二</h2>
<ol>
<li>
<p>启动 Fiddler ，单击菜单栏中的 Tools -&gt; Fiddler Options -&gt; HTTPS，在 Actions 中单击“Export Root Certificate to Desktop ＂</p>
<p>这样可以把 Fiddler 的证书文件导出到电脑桌面上，Fiddler 的证书文件叫“FiddlerRoot.cer“</p>
</li>
<li>
<p>把 Fiddler 证书文件发到手机上。例如可以用 PC 上的 QQ 软件把文件“FiddlerRoot.cer&quot;发送到手机 QQ 上来</p>
<p>这样“ FiddlerRoot.cer”就保存在 了手机中 。比如某存储路径是：内部存储设备 Tencent -&gt; QQfile_recv -&gt; FiddlerRoot.cer</p>
</li>
<li>
<p>打开手机中的设置帽 -&gt; 系统安全 -&gt; 凭据存储 -&gt; 从 SD 卡安装。</p>
</li>
</ol>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210110165400045.png" alt="image-20210110165400045"></p>
<p>4.选择 FiddlerRoot.cer，这样就能成功安装好证书</p>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210110165428947.png" alt="image-20210110165428947"></p>
<h2 id="14-4-10-测试-Fiddler-捕获手机的-HTTPS">14.4.10 测试 Fiddler 捕获手机的 HTTPS</h2>
<p>打开手机上的浏览器，输入 <a href="https://www.baidu.com">https://www.baidu.com</a>， 看看手机能否捕获到百度的 HTTPS 请求。</p>
<h1>14.5 设置过滤</h1>
<p>在手机上设置好代理后，Fiddler 上会抓到 PC 端 的和手机端的所有请求，可以设置过滤。</p>
<p>在 Fiddler 中，选择 File -&gt; Fiddler Options -&gt; HTTPS，选择“from remote clients only”。</p>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210116210432201.png" alt="image-20210116210432201"></p>
<h1>14.6 如何卸载证书</h1>
<p>不同的手机品牌，卸载证书的操作有所差异 。 打开手机中的设置 –&gt; 系统安全 -&gt; 信任的凭据，选择 Fiddler 的证书，单击“删除”即可</p>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210110170523818.png" alt="image-20210110170523818"></p>
<h1>14.7 手机抓包提醒</h1>
<p>手机设置代理后，测试完之后记得把代理关闭，否则手机将不能上网。</p>
<p>对 iPhone 上 iTunes 和 App Store 发出来的 HTTPS 包， Fiddler 很可能抓不到，随着 iOS 的不断升级，在 IOS 设备上抓包会变得越来越困难。</p>
<p>当 Fiddler 证书成功安装在手机上后，手机上会经常提示“网络可能会受到监控，受到不明第三方的监控” 。 这就是因为安装了 Fiddler 证书的原因，可忽略这个提示。</p>
<h1>参考</h1>
<p>《HTTP 抓包实战》</p>
]]></content>
      <categories>
        <category>《HTTP 抓包实战》</category>
      </categories>
      <tags>
        <tag>http</tag>
        <tag>抓包</tag>
      </tags>
  </entry>
  <entry>
    <title>15 Fiddler 发送 HTTP 请求</title>
    <url>/2020/01/09/HTTP%20%E6%8A%93%E5%8C%85%E5%AE%9E%E6%88%98/15%20Fiddler%20%E5%8F%91%E9%80%81%20HTTP%20%E8%AF%B7%E6%B1%82/</url>
    <content><![CDATA[<p>Fiddler 不但可以抓包 ， 还可以修改包，也可以像 JMeter 、Postman 和 RestClient 等工具一样直接发送 HTTP 请求。Fiddler 可以使用重放功能或者 FiddlerComposer 来发送 HTTP 请求。</p>
<p>可以用来做性能测试。</p>
<a id="more"></a>
<h1>15.1 Fiddler Composer 发送 HTTP 请求</h1>
<p>Fiddler 有个功能组件叫 Composer ， 可 以用来发送 HTTP 请求。 Fiddler 的作者把 HTTP Request 发送器取名为 Composer。</p>
<h2 id="15-1-1-Composer-发送-Get-请求">15.1.1 Composer 发送 Get 请求</h2>
<p>启动 Fiddler 找到 Composer 选项卡，手动写一个 HTTP 请求，发送一个 Get 的 HTTP 请求。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GET http:&#x2F;&#x2F;www.cnblogs.com&#x2F;TankXiao&#x2F;p&#x2F;7087990.html HTTP&#x2F;1.1</span><br><span class="line">User-Agent: Fiddler</span><br><span class="line">Host: www.cnblogs.com</span><br></pre></td></tr></table></figure>
<p>Composer 发送 HTTP 请求的界面</p>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210110194834266.png" alt="image-20210110194834266"></p>
<h2 id="15-1-2-Composer-的编辑模式">15.1.2 Composer 的编辑模式</h2>
<p>Composer 有两种编辑模式，具体如下。</p>
<p>Parsed 模式。这个模式比较常用，把 HTTP 请求分为 3 个部分：请求起始行、请求 Header 和请求 Body。通过该模式，创建一个 HTTP 请求变得很容易。</p>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210116210857339.png" alt="image-20210116210857339"></p>
<p>Raw 模式。该模式需要一行一行地写一个 HTTP 请求。</p>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210116210908931.png" alt="image-20210116210908931"></p>
<h2 id="15-1-3-Composer-发送-Post-请求">15.1.3 Composer 发送 Post 请求</h2>
<p>禅道的演示网站是 <a href="http://demo.zentao.net">http://demo.zentao.net</a>，用户名是 <code>demo </code>，密码是 <code>123456</code> ，我们来用 Fiddler 发送一个登录的 Post 请求</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">POST https:&#x2F;&#x2F;demo.zentao.net&#x2F;user-login.html HTTP&#x2F;1.1</span><br><span class="line">Host: derno.zentao.net</span><br><span class="line">User-Agent: QQBrowser&#x2F;9.6.12624.400</span><br><span class="line">Content-Type: application&#x2F;x-wwwforrn-urlencoded</span><br><span class="line"></span><br><span class="line">account&#x3D;derno&amp;password&#x3D;123456</span><br></pre></td></tr></table></figure>
<p>Composer 发送 Post HTTP 请求。</p>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210110195304544.png" alt="image-20210110195304544"></p>
<p>【备注】目前无法使用上述方法进行登陆，猜测是使用了 <code>verifyRand</code> 字段，导致每次登陆只有一次有效性（即该数字不能被重复使用）</p>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210116212253297.png" alt="image-20210116212253297"></p>
<h2 id="15-1-4-Composer-编辑之前捕获的-HTTP-请求">15.1.4 Composer 编辑之前捕获的 HTTP 请求</h2>
<p>在 Web 会话列表中，可以将捕获到的 HTTP 请求拖曳到 Composer 中，编辑后再发送出去。</p>
<h1>15.2 Fiddler 重新发送 HTTP 请求</h1>
<p>Fiddler 可以将捕获的 HTTP 请求重新发送出去。Fiddler 工具栏上有一个 Replay 按钮，单击该按钮可以向 Web 服务器重新发送选中的 HTTP 请求 。当选中多个 Session,并且按下 Replay 按钮后，Fiddler 会用多线程同时发送请求。此功能可以用来做并发的性能测试。</p>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210116212352100.png" alt="image-20210116212352100"></p>
<h2 id="15-2-1-Replay-菜单">15.2.1 Replay 菜单</h2>
<p>按下 Shift 键的同时单击该按钮，会弹出提示框，要求指定每个请求被重新发送的次数。</p>
<p>按下 CTRL 键的同时单击该按钮，在 HTTP 请求中不会包含 <code>IF-Modified-Since</code> 和 <code>If-None-Match</code>。</p>
<p>在会话列表中，选中一个或者多个的 Session，右键菜单我们可以看到一个 Replay 菜单。</p>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210116212542560.png" alt="image-20210116212542560"></p>
<p>Replay 菜单的详细说明：</p>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210110195617963.png" alt="image-20210110195617963"></p>
<h2 id="15-2-2-简单的性能测试">15.2.2 简单的性能测试</h2>
<p>在 Web Sessions 列表中，选中 一个或者多个 Session，然后按下 Shhift 键的同时单击“ Replay＂按钮，会弹出提示框，要求指定每个请求被重新发送的次数。Fiddler 会用多线程同时发送该请求，相当于模拟了很多用户同时访问该请求。</p>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210110195736551.png" alt="image-20210110195736551"></p>
<h2 id="15-2-3-先编辑再发送">15.2.3 先编辑再发送</h2>
<p>在 Web Sessions 列表中，选中一个 Session，单击鼠标右键选择 Replay -&gt; Reissue and Edit，快捷键是 E。该功能可以把一个 HTTP 请求重新发送出去，并且拦截住，将其进行编辑，然后再发出去。</p>
<h1>15.3 安全测试之重放攻击</h1>
<p>Web 安全中，有一种安全测试叫作重放攻击 。重放攻击（ Replay Attacks ）又称重播攻击、回放攻击。软件开发人员和测试人员都需要理解重放攻击的原理，井且防范这种攻击。攻击者发送一个目的主机己接收过的包，特别是在认证的过程中，用于认证用户身份所接收的包，来达到欺骗系统的目的。该包主要用于身份认证过程，破坏认证的安全性。</p>
<h2 id="15-3-1-重放政击是怎么发生的">15.3.1 重放政击是怎么发生的</h2>
<p>重放攻击是指黑客通过抓包的方式，得到客户端的请求数据及请求连接，重复地向服务器发送请求的行为。</p>
<h2 id="15-3-2-重放攻击的危害">15.3.2 重放攻击的危害</h2>
<p>比如 APP 中有一个“下单”的操作，当你单击购买按钮时，APP 向服务器发送购买的请求。而这时黑客对你的请求进行了抓包，得到了你的传输数据。因为你填写的都是真实有效的数据，是可以购买成功的，因此黑客不用做任何改变，直接把你的数据再往服务器提交一次就行了。这就导致了你可能只想购买一个产品， 结果由于黑客重放攻击，你就购买了多次。如果是用户操作的话，肯定会感到莫名其妙：怎么购买了那么多同样的产品 ，我只买了一个啊？所 以 ，重放攻击的危害还是挺大的，特别是涉及金钱交易时。因此防止重放攻击在电商项目中是必不可少的。</p>
<p>很多网站的投票或者点赞功能也要防止重放。黑客会对投票或者点赞进行抓包，然后重复发送来进行刷票。</p>
<h2 id="15-3-3-重放攻击的解决方案">15.3.3 重放攻击的解决方案</h2>
<p>在 HTTP 请求中添加时间戳（ stamp ）和数字签名（ sign ），可以防止重放攻击。也就是说每次发送请求时需要多传两个参数，分别为 stamp 和 sign。比如：原先的请求为 <a href="http://www.669.icu">http://www.669.icu</a>，修改之后的请求为 <a href="https://www.tankxiao/apilbuypro?stamp=1403151835&amp;sign=45f36r46b8df298ad65c9f9241eccd%E3%80%82">https://www.tankxiao/apilbuypro?stamp=1403151835&amp;sign=45f36r46b8df298ad65c9f9241eccd。</a></p>
<p>数字签名是为了确保请求的有效性 。 因为签名是经过加密的，只有客户端和服务器知道加密方式及 Key ，第三方模拟不了。 我们通过对 sign 进行验证来判断请求的有效性，如果 sign 验证失败则判定为无效的请求，反之有效。但是数字签名并不能阻止重放攻击，因为黑客可以抓取你的 stamp 和 sign （不需做任何修改），然后发送请求。这个时候就要对时间戳进行验证 。</p>
<p>时间戳是为了确保请求的时效性。 我们将上一次请求的时间戳进行存储，在下一次请求时，将两次时间戳进行比对 。 如果此次请求的时间戳和上次的相同或小于上一次的时间戳，则判定此请求为过时请求，无效 。 因为正常情况下，第二次请求的时间肯定是比上一次的时间大的，不可能相等或小于 。</p>
<p>有人会问，我直接用时间戳不就行了，为什么还要数字签名？因为黑客可能对请求进行抓包，然后修改时间戳为有效的时间戳值 。 我们的数字签名采用 stamp+key 进行组合加密，即使黑客修改了 stamp ，但是由于黑客不知道 key ，所以 sign 验证这步就成功地阻止了黑客的请求。</p>
<h2 id="15-3-4-APP-验证码重放">15.3.4 APP 验证码重放</h2>
<p>很多 APP 都有注册功能，一般用手机号码注册 。 注册时需要给手机号码发送一个验证码，这个获取验证码的操作应该防范重放攻击。</p>
<p>【实例】：</p>
<ol>
<li>在手机上打开一个 APP，打开注册页面，启动 Fiddler，配置好 Fiddler 手机抓包</li>
</ol>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210110200338020.png" alt="image-20210110200338020"></p>
<ol start="2">
<li>在 App 中输入手机号码，并且单击获取验证码按钮</li>
</ol>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210110200403145.png" alt="image-20210110200403145"></p>
<ol start="3">
<li>在 Fiddler 中，找到能捕获获取验证码的 HTTP 请求</li>
</ol>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210110200431410.png" alt="image-20210110200431410"></p>
<ol start="4">
<li>在 Fiddler 中重放这个请求，选中这个 HTTP 请求，利用 Fiddler 的重放功能可以再次发送验证码，甚至可以修改手机号码再发送 。这样做会给 APP 带来很大的损失 。</li>
</ol>
<h1>15.4 查找和登录相关的 Cookie</h1>
<p>任何一个网站，都会有一个 Cookie 是用来维护登录的，如果浏览器发送的请求没有这个 Cookie，Web 服务器就会返回 302 状态码，让浏览器跳转到登录页面 。</p>
<p>【演示】如何使用 Fiddler 的重放功能来查找维护登录的 Cookie？</p>
<ol>
<li>打开浏览器，访问百度网页，并且登录账号</li>
<li>打开“ <a href="http://i.baidu.com">http://i.baidu.com</a>”，这个页面只有登录状态下才能打开</li>
</ol>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210110200626781.png" alt="image-20210110200626781"></p>
<ol start="3">
<li>启动 Fiddler，再一次打开“ <a href="http://i.baidu.com">http://i.baidu.com</a> ”。我们能用 Fiddler 捕获到浏览器访问“<a href="http://i.baidu.com">http://i.baidu.com</a>“的包。从 HTTP 请求中，我们可以看到浏览器发送了很多个 Cookie。</li>
</ol>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210110200732588.png" alt="image-20210110200732588"></p>
<ol start="4">
<li>在 Web 会话列表中，选择“<a href="http://i.baidu.com">http://i.baidu.com</a>”这个会话，右键单击，选择 Replay -&gt; Reissue and Edit 或者用快捷键 E，这个时候发出去的 HTTP 请求处于可以编辑的状态，删除一个 Cookie，然后单击“ Run to Completion ＂再发出去。</li>
</ol>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210110200809495.png" alt="image-20210110200809495"></p>
<ol start="5">
<li>删除这个 Cookie 后，检查 HTTP 响应，发现还是处于登录状态，说明删除的那个 Cookie 跟登录没有关系</li>
</ol>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210110200837888.png" alt="image-20210110200837888"></p>
<ol start="6">
<li>删除一个名为 BDUSS 的 Cookie，然后再发出去。</li>
</ol>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210110200925321.png" alt="image-20210110200925321"></p>
<ol start="7">
<li>检查 HTTP 响应，可以看到返回的是 302 状态码，说明这个 Cookie 是跟登录相关的</li>
</ol>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210110200950224.png" alt="image-20210110200950224"></p>
<h1>参考</h1>
<p>《HTTP 抓包实战》</p>
]]></content>
      <categories>
        <category>《HTTP 抓包实战》</category>
      </categories>
      <tags>
        <tag>http</tag>
        <tag>抓包</tag>
      </tags>
  </entry>
  <entry>
    <title>16 Fiddler 实现弱网测试</title>
    <url>/2020/01/09/HTTP%20%E6%8A%93%E5%8C%85%E5%AE%9E%E6%88%98/16%20Fiddler%20%E5%AE%9E%E7%8E%B0%E5%BC%B1%E7%BD%91%E6%B5%8B%E8%AF%95/</url>
    <content><![CDATA[<p>在使用 APP 过程中，经常会碰到网速慢 ，甚至网络中断的场景，影响用户体验。这种网速慢和网络中断的情况，我们称之为弱网。要模拟出弱网的环境，就需要用到 Fiddler。使用 Fiddler 能让弱网测试变得非常简单，Fiddler 是通过延迟发送或接收数据的时间来模拟限速的。</p>
<a id="more"></a>
<h1>16.1 什么是弱网</h1>
<p>随着国内移动端的迅速发展，大量的用户会在地铁、隧道、电梯和车库等场景下使用 APP。 这种弱网的场景下，网络会出现延时、中断和超时等情况 。</p>
<p>APP 的开发人员和测试人员 需要针对这些场景，验 i正在弱网的情况下软件的处理机制，从而避免因用户体验不友好造成用户的流失。弱网测试属于健壮性测试。在弱网测试条件下，要测试产品的运行状态、处理机制、提示信息，以及网络恢复后的重连等 。</p>
<p>一般来说，开发人员在 localhost 下调用程序，很难模拟用户真实使用情况，比如正在下载 JS 、css 等静态资源的时候页面的渲染情况。当网速很慢的情况下，我们希望看到的是先渲染出用户界面，而不是让用户看到一片空白。</p>
<h1>16.2 弱网环境带来的问题</h1>
<p>弱网的环境会带来一系列的问题，具体如下。</p>
<ol>
<li>操作时间慢。 用户在地铁里操作手机 APP，由于网络慢，页面加载不出来。原因可能是 API 在网络慢的情况下性能很差。用户在公交车上用手机 APP 看新闻，当公交车进入隧道的时候，网络变得很慢，APP 上的新闻 一直没法加载出来。我们需要测试每个 API 消耗的时间， 这个指标可以衡量 APP 性能的好坏。</li>
<li>用户体验不好。 一个安卓手机用户使用 一款看小说的 APP 在地铁里看小说，当地铁进入隧道的时候，手机信号中断了。用户单击翻页，想看下一页的时候，因为网络中断，APP 的界面卡死并且闪退。原因是 APP 不稳定，没有处理好网络中断的情况 。</li>
<li>非正常情况下，出现 Bug 的可能性会增加。 如一个电商的手机 APP 有秒杀优惠券的功能。一些 APP 用户在乘坐电梯的时候，使用 APP 来秒杀优惠券 。 单击秒杀优惠卷的按钮后，APP 响应缓慢。 于是，用户重复单击秒杀优惠券按钮。 这就造成了几乎同一时间，同一个用户有多个 HTTP 请求发送到服务器，形成了并发，结果用户抢到了多张优惠券。</li>
</ol>
<h1>16.3 弱网测试的目的</h1>
<p>弱网测试的 目的是让 APP 在任何网络下都能表现自如，让开发人员能够预知 APP 在较差网络环境下的表现，提前发现问题 ，进行有针对性的优化。</p>
<h1>16.4 弱网的场景</h1>
<p>模拟出以下 3 种弱网场景：</p>
<ol>
<li>网络慢或延迟，导致加载时间长</li>
<li>网络中断，Web 服务器返回 500 等状态码</li>
<li>网络超时，HTTP 请求发出去后，很久都没有响应</li>
</ol>
<h1>16.5 Fiddler 模拟网络延迟</h1>
<p>为了重现这些问题，我们需要用软件来模拟出网络慢的情况。我们可以用 Fiddler 来限速。</p>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210110201716375.png" alt="image-20210110201716375"></p>
<p>已经讲过如何用 Fiddler 捕获手机 APP 的 HTTP 请求，在弱网测试中我们也需要捕获手机 APP 的 HTTP 请求，然后限速。</p>
<p>【实例】当浏览器访问博客园网站的时候，用 Fiddler 来限速</p>
<ol>
<li>启动 Fiddler，选择 Rules -&gt; Performances -&gt; Simulate Modem Speeds</li>
</ol>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210117015755302.png" alt="image-20210117015755302"></p>
<ol start="2">
<li>打开浏览器，访问 <a href="http://www.cnblogs.com/liqingwen/%E3%80%82%E4%BD%A0%E4%BC%9A%E5%8F%91%E7%8E%B0%E6%89%93%E5%BC%80%E7%BD%91%E9%A1%B5%E7%9A%84%E9%80%9F%E5%BA%A6%E5%BE%88%E6%85%A2">http://www.cnblogs.com/liqingwen/。你会发现打开网页的速度很慢</a></li>
</ol>
<h1>16.6 精确控制网速</h1>
<p>我们还可以精确控制网速，可以通过修改 Fiddler Script 来实现。</p>
<p>具体的操作步骤如下：</p>
<ol>
<li>启动 Fiddler，选择 Rules -&gt; Performances -&gt; Simulate Modem Speeds</li>
<li>在 FiddlerScript 中找到如下一段代码：</li>
</ol>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210110202151599.png" alt="image-20210110202151599"></p>
<p>把数值改大 一点，比如修改为 oSession=[“request-trickle- delay”]=“900”，oSession[”response-trickle-delay&quot;]=“600”。修改完之后保存 Script。</p>
<ol start="3">
<li>
<p>保存完之后，原本己经勾选的 Simulate Modem Speeds 会被取消勾选；再次选中 Rules -&gt; Performances -&gt; Simulate Modem Speeds。</p>
</li>
<li>
<p>再次打开浏览器，访问 <a href="http://www.cnblogs.com/tankxiao/%E3%80%82%E4%BD%A0%E4%BC%9A%E5%8F%91%E7%8E%B0%EF%BC%8C%E6%89%93%E5%BC%80%E7%BD%91%E9%A1%B5%E5%8F%98%E5%BE%97%E6%9B%B4%E6%85%A2%E4%BA%86%E3%80%82">http://www.cnblogs.com/tankxiao/。你会发现，打开网页变得更慢了。</a></p>
</li>
</ol>
<p>网络取值的算法就是 1000/下载速度＝需要延迟的时间（ms），比如 50kbit/s 需要延迟 200ms 来接收数据 。</p>
<h2 id="16-7-Fiddler-模拟网络中断">16.7 Fiddler 模拟网络中断</h2>
<p>用 Fiddler 可以下断点，伪造 HTTP 响应。移动端发出的 HTTP 请求根本没有到达服务器，而是被 Fiddler 直接返回了 一个伪造的 HTTP 响应。</p>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210110202545555.png" alt="image-20210110202545555"></p>
<p>Fiddler 具有下断点的功能，我们可以利用 Fiddler 直接返回 500、503 等各种状态码。</p>
<p>具体做法是用 Fiddler 拦截住移动端发出 来的 HTTP 请求，然后在“ Choose Response &quot;选中需要返回的状态码并返回给移动客户端。</p>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210110202622849.png" alt="image-20210110202622849"></p>
<h1>16.8 实例：Fiddler 返回 500 状态码</h1>
<ol>
<li>在桌面上新建一个 txt 文件，里面的内容如下：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HTTP&#x2F;1.1 500 Internal Server Error</span><br><span class="line">Date: Fri, 11 Aug 2017 07 :25:35 GMT</span><br><span class="line">Content-Type: text&#x2F;html; char set&#x3D;utf 8</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Vary: Accept -Encoding</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">this is 500 internal Server Error by Fiddler! tank</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>在 Fiddler 中设置断点，打开浏览器，访问 <a href="http://www.cnblogs.com/tankxiao/p/7087990.html">http://www.cnblogs.com/tankxiao/p/7087990.html</a></li>
<li>Fiddler 会拦截住这个请求，选择“ Find a file …“选择桌面上的 txt 文件，然后单击“Run to Comp letion ”</li>
</ol>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210110202852593.png" alt="image-20210110202852593"></p>
<ol start="4">
<li>这样 Fiddler 就把 500 状态码，返回给了浏览器。</li>
</ol>
<h1>16.9 Fiddler 模拟网络超时</h1>
<p>利用 Fiddler 下断点的功能拦截住移动客户端发出的 HTTP 请求，这样就相当于网络超时了，然后再检查客户端有没有重发或者超时的机制。</p>
<h1>参考</h1>
<p>《HTTP 抓包实战》</p>
]]></content>
      <categories>
        <category>《HTTP 抓包实战》</category>
      </categories>
      <tags>
        <tag>http</tag>
        <tag>抓包</tag>
      </tags>
  </entry>
  <entry>
    <title>19 JMeter 天气接口自动化测试</title>
    <url>/2020/01/09/HTTP%20%E6%8A%93%E5%8C%85%E5%AE%9E%E6%88%98/19%20JMeter%20%E5%A4%A9%E6%B0%94%E6%8E%A5%E5%8F%A3%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/</url>
    <content><![CDATA[<p>本章通过“查询天气接口”的例子，来讲述 JMeter 中参数化、断言、关联、正则表达式的用法 。</p>
<a id="more"></a>
<h1>19.1 天气查询的例子</h1>
<p>手动查询天气 的步骤：</p>
<ol>
<li>打开浏览器，打开 <a href="http://www.weather.com.cn/">http://www.weather.com.cn/</a></li>
<li>在“城市名称”中输入“上海”，单击查询，就能查询到上海的天气 。接下来我们把这个天气查询的例子做成自动化。</li>
</ol>
<h1>19.2 天气查询网站抓包</h1>
<p>启动 Fiddler，单击菜单栏中 Rules -&gt; Hide Image Requests 。 抓包的时候，如果抓了 太多不相干的包，干扰会很大，所以我把图片的包都隐藏了。</p>
<p>打开浏览器，打开 <a href="http://www.weather.com.cn/%EF%BC%8C%E5%9C%A8%E2%80%9C%E5%9F%8E%E5%B8%82%E5%90%8D%E7%A7%B0%E2%80%9D%E4%B8%AD%E8%BE%93%E5%85%A5%E2%80%9C%E4%B8%8A%E6%B5%B7%E2%80%9C%EF%BC%8C%E5%8D%95%E5%87%BB%E6%9F%A5%E8%AF%A2%E6%8C%89%E9%92%AE%E3%80%82">http://www.weather.com.cn/，在“城市名称”中输入“上海“，单击查询按钮。</a></p>
<p>通过 Fiddler 抓包，会抓到几十个包。</p>
<h1>19.3 抓包分析</h1>
<p>通过上面的抓包，我们经过分析可以知道实际上是做了 2 步。</p>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210111003646994.png" alt="image-20210111003646994"></p>
<ol>
<li>
<p>第一步 ：获取城市代码</p>
<p>发送一个 GET 请求到 <a href="http://toyl.weather.com.cn/search?cityname=%E4%B8%8A%E6%B5%B7%EF%BC%88%E6%B3%A8%E6%84%8F">http://toyl.weather.com.cn/search?cityname=上海（注意</a> ， “上海”被 URLEncode 后变成了“ %E4%B8%8A%E6%B5%B7“）。</p>
<p>从这个响应中可以得到上海的地区代码，比如上海的地区代码是 101020100 。</p>
<p>【注意 】这个请求必须带上一个 叫“ Referer ”的 Header，Referer 的作用 就是用来追踪来源的。</p>
</li>
<li>
<p>第二步：获取城市的天气数据。</p>
<p>发送一个 GET 请求到 <a href="http://www.weather.eom.cn/weatherld/101020100.shtml%EF%BC%8C%E5%8F%AF%E4%BB%A5%E5%BE%97%E5%88%B0%E8%AF%A5%E5%9F%8E%E5%B8%82">http://www.weather.eom.cn/weatherld/101020100.shtml，可以得到该城市</a> 的天气数据 。</p>
<p>另外，我们还需要做把城市参数化，这样就可以查询任何一个城市的天气 。 第一个请求查询到的数据要传给第二个请求使用，我们称之为关联。</p>
</li>
</ol>
<h1>19.4 获取城市地区代码</h1>
<p>现在我们用 JMeter 来发包，实现整个过程，具体的操作步骤如下。</p>
<ol>
<li>启动 JMeter，新建一个线程组（ Thread Group ）</li>
<li>在线程组下面新建一个 HTTP 请求，将其命名为 GetCityCode。发送一个 Get 方法的 HTTP 请求到 <a href="http://toyl.weather.com.cn/search?cityname=%E4%B8%8A%E6%B5%B7">http://toyl.weather.com.cn/search?cityname=上海</a></li>
</ol>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210111004139998.png" alt="image-20210111004139998"></p>
<p>添加一个 HTTP 信息头管理器，添加一个 Referer。</p>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210111004203257.png" alt="image-20210111004203257"></p>
<p>再添加一个察看结果树，就可以运行查看结果了，如图 19-4 所示 。 注意这里的汉字变成乱码了 。</p>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210111004232183.png" alt="image-20210111004232183"></p>
<h1>19.5 处理 JMeter 中 HTTP 响应乱码</h1>
<p>为什么中文会显示为乱码呢？</p>
<p>当响应数据或响应页面没有设置编码时，JMeter 会按照 jmeter .properties 文件中的 sampleresult.default.encoding 设置的格式解析 。 默认是 IS0-8859-1，所以解析中文时肯定会出错 。jmeter.properties 文件在 \apache-jmeter-3.2\bin 下面，内容如下：</p>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210111004336147.png" alt="image-20210111004336147"></p>
<p>重新启动 JMeter，打开脚本，重新运行。</p>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210111004626057.png" alt="image-20210111004626057"></p>
<h1>19.6 添加验证点</h1>
<p>选择 GetCityCode 这个 HTTP 请求，用鼠标右键选择添加－＞断言－＞响应断言。</p>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210111004652397.png" alt="image-20210111004652397"></p>
<p>选择线程组，用鼠标右键选择添加，＞监听器”＞断言结果 。</p>
<p>运行后，如果 HTTP 响应中没有包含期待的宇符串，那么断言就会失败。</p>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210111004947109.png" alt="image-20210111004947109"></p>
<h1>19.7 使用用户自定义变量</h1>
<p>我们还可以在几1eter 中定义变量。 比如我们定义一个变量叫 city，调用这个变量的时候用 ${city｝。<br>
选择线程组，用鼠标右键选择添加 -＞配置元件·＞用户定义的变量。</p>
<p>我们添加一个变量 city ，其值设为“上海”。</p>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210111011128382.png" alt="image-20210111011128382"></p>
<p>然后在 GetCityCode 中使用这个变量。</p>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210111011152330.png" alt="image-20210111011152330"></p>
<p>这样我们就实现了参数化，以后修改城市的时候，只要修改用户自定义变量就可以了 。</p>
<h1>19.8 正则表达式提取城市地区代码</h1>
<p>如果你不熟悉正则表达式，请去百度搜索“正则表达式 30 分钟入门教程”。 正则表达式的教程和工具可以到 <a href="https://deerchao.ne/torials/regex/regex-1.htm">https://deerchao.ne/torials/regex/regex-1.htm</a> 下载 。</p>
<p>推荐先使用 一个正则表达式测试器测试一下你的正则表达式字符串是否正确。方法是把 GetCityCode 的 HTTP 响应复制到正则表达式工具中，测试一下正则表达式字符串是否正确 。</p>
<p>例如，我们的正则表达式字符串是(\d{9}?～.*～上海</p>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210111011247190.png" alt="image-20210111011247190"></p>
<p>选择 GetCityCode 这个 HTTP 请求，用鼠标右键选择添加 –&gt; 后置处理器”＞正则表达式提取器</p>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210111011402224.png" alt="image-20210111011402224"></p>
<p>所谓关联 ， 就是一个 HTTP 请求使用了另一个 HTTP 请求中的数据，两个请求之间发生了关联。</p>
<p>通过正则表达式提取器，我们把城市代码提取出来，并且存到变量 citycode ，然后把这个变量提供给第二个 HTTP 请求使用。</p>
<h1>19.9 获取天气</h1>
<p>现在新建第二个 HTTP 请求，命名为 GetWeather。发送一个 GET 请求到 <a href="http://www.weather.com.en/weather1d/$%7Bcitycode%7D">http://www.weather.com.en/weather1d/${citycode}</a> .shtml 。</p>
<p>${citycode} 中的数据是从正则表达式中提取来的。</p>
<p>现在 ，脚本全部写好了。运行后，在“察看结果树”中查看结果。</p>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210111011556119.png" alt="image-20210111011556119"></p>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210111011607192.png" alt="image-20210111011607192"></p>
<h1>参考</h1>
<p>《HTTP 抓包实战》</p>
]]></content>
      <categories>
        <category>《HTTP 抓包实战》</category>
      </categories>
      <tags>
        <tag>http</tag>
        <tag>抓包</tag>
      </tags>
  </entry>
  <entry>
    <title>17 自动化测试和接口测试</title>
    <url>/2020/01/09/HTTP%20%E6%8A%93%E5%8C%85%E5%AE%9E%E6%88%98/17%20%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E5%92%8C%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95/</url>
    <content><![CDATA[<p>当今我们正处于互联网时代，特别是移动互联网 时代 。 大量的程序都是以 APP 或者 Web 的形式提供给用户使用。 测试人员现在主要测试的是 APP 或者 Web 端 。按照架构程序可以分为前端和后台。有的测试人员测试前端，有的测试后台。学好了 HTTP 协议和 Fiddler，可以将其应用到后台的自动化测试和接口的自动化测试。</p>
<a id="more"></a>
<h1>17.1 自动化测试分类</h1>
<p>自动化测试的种类非常多。</p>
<h1>17.2 分层的自动化测试理念</h1>
<p>最底层的单元测试是属于开发人员做的。</p>
<p>最上层的 UI 自动化测试，就是用程序模拟用户手工操作的测试方法，模拟鼠标键盘的操作，能够帮助测试人员从重复和枯燥的手工测试中解放出来 。 比如使用 Selenium 来做 Web 的 UI 自动化测试，使用 Appium 来对于机 UI 做自动化测试。UI 层的自动化测试工具非常多。将 UI 自动化测试在真正的工作中时，测试人员会发现理想和现实之间差距很大。</p>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210110203338196.png" alt="image-20210110203338196"></p>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210110203352462.png" alt="image-20210110203352462"></p>
<p>为什么外部环境、业务变更和应用环境问题能导致这么多 UI 自动化失败呢？这是因为 UI 自动化存在以下的缺点：</p>
<ol>
<li>UI 自动化是非常不稳定的。网速、浏览器、脚本的健壮性和测试环境等因素都会导致 UI 自动化测试的失败</li>
<li>做 UI 自动化测试成本非常高，对测试人员要求也很高一一需要懂自动化框架，会一门编程语言，同时还需要代码逻辑清晰</li>
<li>UI 自动化效果差，发现不了几个 Bug。UI 自动化测试搞不好可能会成为鸡肋</li>
<li>维护性差，当 UI 发生改变的时候，UI 自动化测试用例会大量失效，测试人员不得不花时间去修改 UI 自动化测试代码</li>
</ol>
<p>虽然 UI 自动化测试对项目来说有时候可能没有太大作用，但是对测试人员自身来说却有非常大的帮助 。在做 UI 自动化测试的过程中，测试人员会碰到各种各样的问题 ，然后他们会想办法去解决问题，这个过程能大大提高测试人员的能力。</p>
<h1>17.3 Web 自动化测试的两种思路</h1>
<ol>
<li>
<p>UI 自动化测试，或者叫 Browser 测试， 模拟浏览器端的一些操作，比如在 TextBox 输入一些文本，选择下拉框中的某个选项。使用 Selenium 这样的 UI 自动化测试框架，模拟用户的操作，比如自动打开浏览器；然后自动输入用户名和密码，自动单击登录按钮。</p>
</li>
<li>
<p>用发包工具模拟浏览器的发包，直接发送 HTTP 请求给 Web 服务器，然后对服务器响应回来的行进行解析和验证。</p>
<p>这两种自动化测试的方法各有优缺点。浏览器的 UI 自动化测试能够模拟用户真实的操作场景，但是运行很慢，而且不稳定，自动化测试代码维护成本非常高。基于 HTTP 协议的自动化测试运行速度快，稳定，但是没有对 UI 和脚本进行测试。</p>
</li>
</ol>
<h1>17.4 什么是接口测试</h1>
<p>接口是指模块与模块之间的对接方式定义，或者是系统与系统之间的对接方法定义。接口是可以部署成服务的协议接口，常见的协议就是 HTTP 协议。</p>
<p>所以测试人员平常说的接口测试或者 Web 接口测试、Restful API 测试，就是基于 HTTP 协议的接口测试。除了基于 HTTP 协议的接口，还有基于其他协议的接口，其本质都是要发送一个 HTTP 请求报文给服务器，然后服务器返回 一个 HTTP 响应报文。</p>
<p>接口一般比较稳定，改动不会很频繁，所以接口的自动化测试的维护成本就比较低 。一般来说，接口测试是最简单的自动化测试，甚至不需要写多少代码，用自动化工具就能实现自动化测试，接口测试能发现很多 Bug 。</p>
<p>手动测试人员如果想转型做自动化测试，从接口自动化测试开始入门是一个非常好的选择。</p>
<h1>17.5 接口测试工具</h1>
<ol>
<li>抓包工具：Fiddler、Firebug 、HTTP Analyzer</li>
<li>发包工具：开源工具有 JMeter 、Postman，商业工具有 LoadRunner 、SoapUI 。</li>
</ol>
<h1>17.6 Web 原理</h1>
<p>当我们在浏览器的地址栏中输入 URL，就能打开一个网页，那么网页是如何呈现的呢？具体过程如下 。</p>
<ol>
<li>浏览器（Browser）是客户端，发送 HTTP 请求给 Web 服务器（Server）</li>
<li>Web 服务器接受了请求后，生成相应的 HTTP 响应（Response），然后发送给浏览器。</li>
<li>浏览器解析 HTTP 响应，这样我们就看到页面了 。 这就是我们说的 Browser/Server 结构，简称 B/S 结构。</li>
</ol>
<p>在浏览器中输入  <a href="http://www.cnblogs.com/liqingwen%E3%80%82">http://www.cnblogs.com/liqingwen。</a></p>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210110204637463.png" alt="image-20210110204637463"></p>
<h1>17.7 Web 自动化测试原理</h1>
<p>用自动化工具把自己伪装成一个浏览器，发送 HTTP 请求给 Web 服务器，这就是自动化测试原理。市面上能发送 HTTP 请求的工具很多 ，常用的有 JMeter、 Load.Runner 、 Postman 等。</p>
<p>另外，几乎所有的编程语言都能发送 HTTP 请求。</p>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210110204739192.png" alt="image-20210110204739192"></p>
<h1>17.8 性能测试的原理</h1>
<p>性能测试实际上也是通过工具模拟出很多虚拟的用户，同时发送 HTTP 请求给 Web 服务器。对被测系统实行压力负载测试，监控被测系统在不同业务不同压力下的性能表现，找出潜在的性能瓶颈并对其进行分析、优化。</p>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210110204820082.png" alt="image-20210110204820082"></p>
<h1>17.9 APP 的后台测试</h1>
<p>移动 APP 的架构一般是由前端 的 APP 调用后台的 Web 服务器，Web 服务器提供了很多接口。</p>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210110204854341.png" alt="image-20210110204854341"></p>
<p>APP 的后台其实就是 Web Server ，也是通过 HTTP 协议暴露出来 的 API（或者叫接口）。</p>
<p>如果我们要直接测试 APP 的后台服务，则可以使用自动化测试工具，直接调用后台的 API。</p>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210110204954698.png" alt="image-20210110204954698"></p>
<h1>17.10 如何学习 Web 自动化测试和性能测试</h1>
<p>做 Web 自动化测试和性能测试，最重要的是要理解 HTTP 协议，然后再学会用工具模拟出同样的 HTTP 请求发送给服务器，或者自己写代码模拟出相同的 HTTP 请求。</p>
<p>HTTP 协议是一个数据包，我们怎么样才能看到这个数据包的样子呢？我们需要找一个抓包工具来抓 HTTP 的数据包，查看数据包中有什么字段。</p>
<p>我们用什么工具来发送 HTTP 协议数据包呢？我选择用 JMeter 来发送 HTTP 数据包，因为 JMeter 的功能强大井且简单易学，不需要写代码，使用非常方便。</p>
<h1>参考</h1>
<p>《HTTP 抓包实战》</p>
]]></content>
      <categories>
        <category>《HTTP 抓包实战》</category>
      </categories>
      <tags>
        <tag>http</tag>
        <tag>抓包</tag>
      </tags>
  </entry>
  <entry>
    <title>18 JMeter 工具使用介绍</title>
    <url>/2020/01/09/HTTP%20%E6%8A%93%E5%8C%85%E5%AE%9E%E6%88%98/18%20JMeter%20%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<p>JMeter 是一款优秀的开源测试工具，广泛用于接口测试和性能测试。熟练使用 JMeter 后，能用 JMeter 搞定的事情就不必使用 LoadRunner 了。</p>
<a id="more"></a>
<h1>18.1 JMeter 介绍</h1>
<p>Apache JMeter 是 Apache 组织开发的基于 Java 的压力测试工具，用于对软件做压力测试。它最初被设计用于 Web 应用测试，后来才扩展到其他测试领域。</p>
<p>JMeter 给大多数人的第一印象是性能测试工具。实际上，性能测试就是调用 Web 接口。所以现在经常用 JMeter 测试 Web 接口，用 JMeter 来测试 Restful API 非常好用 。</p>
<p>如果使用 JMeter 去对 Web 进行功能测试或者性能测试，应该熟练掌握 HTTP 协议。</p>
<h1>18.2 JMeter 的下载和运行</h1>
<p>JMeter 的官方网站是 <a href="http://jmeter.apache.org/%E3%80%82">http://jmeter.apache.org/。</a></p>
<p>JMeter 由 Java 语言开发 。JMeter3.2 版本的运行需要有 Java8 或者以上版本的环境，需要安装好 JavaJDK，配置好环境变量。关于 Java 环境的安装请参考其他资料，此处不再作详细讲解 。</p>
<p>JMeter 不需要安装，只需要配置好 JAVA 环境，解压后即可直接运行。将“apache-jmeter-3.2.zip”文件解压，进入解压目录“…/apache-jmeter-3.2/bin/”下双击 jmeter.bat，就能启动 JMeter。</p>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210110210259147.png" alt="image-20210110210259147"></p>
<p>JMeter 是支持中文的。启动 JMeter 后，单击 Options -&gt; Choose Language 来选择语言。</p>
<h1>18.3 创建测试任务</h1>
<p>在 JMeter 中，任何类型的测试都需要先创建线程组，一个线程组可以看作一个测试任务 。</p>
<p>添加线程组，用鼠标右键单击 “测试计划”，在快捷菜单中单击添加 -&gt; Threads(Users)  -&gt; 线程组。</p>
<p>注意：在 JMeter 中，任何内容都应该放在线程组中。</p>
<p>设置线程组 。 线程组主要包括 3 个参数，</p>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210110231930902.png" alt="image-20210110231930902"></p>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210110231939745.png" alt="image-20210110231939745"></p>
<ol>
<li>线程数：一个线程代表一个虚拟用户</li>
<li>Ramp-Up Period(in seconds）：设置线程的启动时长，单位为 s。如果线程数是 100，启动时长为 s，那么需要 5s 启动 100 个线程，平均每秒启动 20 个线程</li>
<li>循环次数：每个线程发送请求的次数。如果这个线程组中有 5 个 HTTP 请求，循环次数为 3 的话，那么 一个线程会发送 5 × 3=15 个 HTTP 请求。如果选中了“永远”复选框，那么所有的线程会无限循环发送请求，直到手动单击工具栏上的停止按钮 。</li>
</ol>
<p>如果用来做功能测试／接口测试，那么应保持默认设置，线程数设置为 1，Ramp-up Period( in seconds）设置为 1，循环次数也设置为 1。</p>
<h1>18.4 添加 HTTP 请求</h1>
<p>构造出 一个 HTTP 请求的数据包 。</p>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210110232134735.png" alt="image-20210110232134735"></p>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210110232143415.png" alt="image-20210110232143415"></p>
<h1>18.5 实例：密码用 MD5 加密</h1>
<p>有一个 MD5 在线网站，网址是 <a href="http://www.md5.cz/%EF%BC%8C%E5%88%A9%E7%94%A8%E5%AE%83%E5%8F%AF%E4%BB%A5%E5%AF%B9%E6%88%91%E4%BB%AC%E7%9A%84%E5%AF%86%E7%A0%81%E8%BF%9B%E8%A1%8C%E6%95%A3%E5%88%97%E5%A4%84%E7%90%86">http://www.md5.cz/，利用它可以对我们的密码进行散列处理</a> 。 我们用 Fiddler 对这个网站进行抓包，然后用 JMeter 来实现。具体的操作步骤如下。</p>
<ol>
<li>首先启动 Fiddler，打开浏览器，输入 <a href="http://www.md5.cz/%EF%BC%8C%E5%9C%A8%E9%A1%B5%E9%9D%A2%E4%B8%AD%E8%BE%93%E5%85%A5%E2%80%9Cpassword">http://www.md5.cz/，在页面中输入“password</a> ”，然后单击按钮“ hash darling, hash!”。</li>
</ol>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210110232411679.png" alt="image-20210110232411679"></p>
<p>浏览器发出的 HTTP 请求报文如下 ：</p>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210110232432701.png" alt="image-20210110232432701"></p>
<ol start="2">
<li>
<p>现在我们需要使用 JMeter 发送一个一模一样的 HTTP 请求报文。启动 JMeter，添加线程组，添加一个 HTTP 请求。</p>
<p>一个网址被分割成了 4 部分。</p>
<p>协议（http）＋服务器名称或 IP (<a href="http://www.md5.cz">www.md5.cz</a>) ＋端口号（默认是 80 ，不需要填写）＋路径（/getmd5 .php ) = http ://www.md5.cz!getmd5 .php 。</p>
</li>
</ol>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210110232810826.png" alt="image-20210110232810826"></p>
<p>​	这个 HTTP 是 POST 方法，是有 Body 的。我们选择 POST 方法，并且在 Body Data 中填写“ what=password ”</p>
<ol start="3">
<li>添加 HTTP Header。选择这个 HTTP 请求，用鼠标右键单击，选择添加·＞配置元件-＞HTTP 信息头管理器</li>
</ol>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210111002207465.png" alt="image-20210111002207465"></p>
<p>有个简单的办法可以添加 HTTP Header （信息头），即先在 Fiddler 中复制所有的 HTTP Header，然后单击“ Add from Clipboard”。</p>
<ol start="4">
<li>HTTP 信息头管理器中删除 Host。JMeter 会自动帮你添加 Host ，所以不需要手动添加。如果己经手动添加，则需要删除。</li>
</ol>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210111002330135.png" alt="image-20210111002330135"></p>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210111002353010.png" alt="image-20210111002353010"></p>
<ol start="5">
<li>添加察看结果树。选择线程组，用鼠标右键选择添加 –＞监听器 -&gt; 察看结果树。</li>
<li>运行 JMeter，单击工具栏上的绿色按钮，可以运行脚本，系统会提示你保存脚本 。</li>
<li>通过结果树，我们可以看到我们发出的 HTTP？请求，以及 Web 服务器返回的 HTTP 响应。</li>
</ol>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210111002826912.png" alt="image-20210111002826912"></p>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210111002837745.png" alt="image-20210111002837745"></p>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210111002846513.png" alt="image-20210111002846513"></p>
<p>password 被散列（hash）后 ， 变成 5f4xxxxxxxxxxx。</p>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210111002942919.png" alt="image-20210111002942919"></p>
<ol start="8">
<li>JMeter 中查看 HTTP 的响应。我们可以使用 多种方式来查看 HTTP 响应， 如果 HTTP 晌应是一个 HTML 文档，则可 以使用 HTML 方式 ；如果 HTTP 响应是一个 JSON 文件，则可以使用 JSON Path Tester 方式查看。</li>
</ol>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210111003019683.png" alt="image-20210111003019683"></p>
<h1>参考</h1>
<p>《HTTP 抓包实战》</p>
]]></content>
      <categories>
        <category>《HTTP 抓包实战》</category>
      </categories>
      <tags>
        <tag>http</tag>
        <tag>抓包</tag>
      </tags>
  </entry>
  <entry>
    <title>20 JMeter 中 Bean Shell 的用法</title>
    <url>/2020/01/09/HTTP%20%E6%8A%93%E5%8C%85%E5%AE%9E%E6%88%98/20%20JMeter%20%E4%B8%AD%20Bean%20Shell%20%E7%9A%84%E7%94%A8%E6%B3%95/</url>
    <content><![CDATA[<p>我们在使用 JMeter 的时候，有时候会需要一些逻辑的运行，对此 JMeter 就有些乏力了。可以在 BeanShell 中通过 Java 代码来扩展功能。</p>
<a id="more"></a>
<h1>20.1 什么是 BeanShell</h1>
<p>BeanShell 是一个小型的 Java 源代码解释器，具有对象脚本语言特性。其能够动态执行标准 JAVA 语法，可以通过脚本来处理 Java 应用程序，还可以执行 JAVA 代码和 Java 代码片段，以及松散类型的 Java 和其他的脚本。BeanShe ll 是一种完全符合 Java 语法规范的脚本语言，并且拥有自己的一些语法和方法。</p>
<h1>20.2 操作变量</h1>
<p>通过使用 Bean shell 内 置对象 vars 可以对变量进行存取操作。</p>
<p>vars.get（”name”）：从 JMeter 中获得变量值。</p>
<p>vars.put(&quot;key”，”value＂）：数据存到 JMeter 变量中 。</p>
<p>新建一个线程组，添加一个 BeanShell Sampler，添加一个 Debug Sampler 和一个“ 察看结果树。</p>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210113010051381.png" alt="image-20210113010051381"></p>
<p>在“ 察看结果树”中，我们可以通过 Debug Sampler 来查看变量的值。</p>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210113012931725.png" alt="image-20210113012931725"></p>
<h1>20.3 JMeter 有哪些 BeanShell</h1>
<p>JMeter 中包括多种 BeanShell， 用法基本都是一样的，只是作用的地方不同而己，可以都尝试一下看看 。</p>
<p>定时器 ：BeanShell Timer 。</p>
<p>前置处理器 ：BeanShell Pr巳Processor 。</p>
<p>采样器 ：BeanShell Sampler 。</p>
<p>后置处理器：BeanShell PostProcessor 。</p>
<p>断言：BeanShell 断言。</p>
<p>监听器：BeanShell Listener 。</p>
<h1>20.4 BeanShell 调用自己写的 jar 包进行 MD5 加密</h1>
<p>具体操作步骤如下。</p>
<ol>
<li>先在 Eclipse 中新建一个工程 ，工程名随便取</li>
<li>在工程中添加一个 class，class 名称叫 md5，代码如下：</li>
</ol>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210113013138656.png" alt="image-20210113013138656"></p>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210113013152112.png" alt="image-20210113013152112"></p>
<ol start="3">
<li>将工程导出为一个 jar 文件，取名为 mymd5.jar</li>
<li>新建另 一个工程，取名为 mdStest，引入 mymd5.jar。测试一下 jar 包，确保 jar 包能被正确调用。允许成功后，说明 jar 包是可用的</li>
</ol>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210113013244677.png" alt="image-20210113013244677"></p>
<ol start="5">
<li>将 mymdS.jar 复制到 JMeter 文件中的 apache-jmeter-3 .2\lib \ext 下面</li>
<li>启动 JMeter ，在测试计划中引入这个 jar 包</li>
</ol>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210113013322558.png" alt="image-20210113013322558"></p>
<ol start="7">
<li>
<p>几位ter 中新建一个线程组，线程组中新建一个 BeanShell Sampler</p>
</li>
<li>
<p>在线程组下面添加一个 Debug Sampler。</p>
</li>
<li>
<p>在线程组下面添加一个察看结果树</p>
</li>
</ol>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210113013401765.png" alt="image-20210113013401765"></p>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210113013414818.png" alt="image-20210113013414818"></p>
<h1>参考</h1>
<p>《HTTP 抓包实战》</p>
]]></content>
      <categories>
        <category>《HTTP 抓包实战》</category>
      </categories>
      <tags>
        <tag>http</tag>
        <tag>抓包</tag>
      </tags>
  </entry>
  <entry>
    <title>22 JMeter 给网站做压力测试</title>
    <url>/2020/01/09/HTTP%20%E6%8A%93%E5%8C%85%E5%AE%9E%E6%88%98/22%20JMeter%20%E7%BB%99%E7%BD%91%E7%AB%99%E5%81%9A%E5%8E%8B%E5%8A%9B%E6%B5%8B%E8%AF%95/</url>
    <content><![CDATA[<p>本章介绍如何使用 Fiddler 抓包分析网站的登录过程，并且使用 JMeter 实现网站的自动登录，从而实现自动化测试以及性能测试。</p>
<a id="more"></a>
<h1>22.1 案例介绍</h1>
<p>本章介绍如何给网站做压力测试，使用的是一个叫 Mozy 的网站。</p>
<p>其登录页面是 <a href="https://secure.mozy.com/login">https://secure.mozy.com/login</a> ，用户名是 246460253l@qq.eom ，密码是 tanJαiao1234。</p>
<p>建议读者注册自己的账号来完成本次操作，注册网址是 <a href="https://secure.mozy.com/registration/ee%E3%80%82">https://secure.mozy.com/registration/ee。</a></p>
<p>性能测试的脚本其实就是自动化测试。</p>
<h1>22.2 压力测试的目的</h1>
<p>模拟 20 个用户同时登录 Mozy 网站进行操作，然后查看性能指标，比如响应时间和出错率。</p>
<h1>22.3 抓包分析 Mazy 网站的登录过程</h1>
<ol>
<li>启动 Fiddler，打开浏览器，打开 <a href="https://secure.mozy.com/login%EF%BC%8C%E8%BE%93%E5%85%A5%E7%94%A8%E6%88%B7%E5%90%8D">https://secure.mozy.com/login，输入用户名</a> 246460253 l @qq.eom 和密码 tankxiao 1234</li>
</ol>
<p>Fiddler 能抓到很多包，找到那个有用户名和密码的包</p>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210113020434373.png" alt="image-20210113020434373"></p>
<p>抓包可以看到，浏览器用 POST 方法发送了如下数据给服务器 ：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">authenticity _token司~K4Ig6s3j57plJ%2F5rWGCXDVFbr6时L1也uyklxbwDHU%3D＆山em缸ne&#x3D;2464602531%40qq.com&amp;password&#x3D;tankxiao1234</span><br></pre></td></tr></table></figure>
<p>除 了用户名和密码外，还有一个 authenticity_token 。 这个 authenticity_token 是从哪里来的呢？（如果 authenticity_token 每次都变化，说明服务器会验证对其进行）</p>
<ol start="2">
<li>查找 authenticity_token 的来源。在 Fiddler 中，按快捷键【Ctrl+F】 来查找</li>
</ol>
<p>查到的 Session 会用黄色的背景显示，我们得知这个 authenticity_token 是从 <a href="https://secure.mozy.com/login">https://secure.mozy.com/login</a> 这个页面的响应中来的</p>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210113020958743.png" alt="image-20210113020958743"></p>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210113021007289.png" alt="image-20210113021007289"></p>
<h1>22.4 抓包分析</h1>
<p>通过上面的抓包分析，我们可以总结出整个过程如下 。</p>
<ol>
<li>发一个 GET 的 HTTP  请求到 <a href="https://secure.mozy.com/l%E3%80%82%E4%BD%86%E6%98%AF%EF%BC%8C%E5%9C%A8%E8%BF%99%E4%B8%AA%E9%A1%B5%E9%9D%A2%E7%9A%84">https://secure.mozy.com/l。但是，在这个页面的</a> HTTP 响应中，用正则表达式提取到 authenticity_token 的值。</li>
<li>发一个 POST 的 HTTP 请求到 <a href="https://secure.mozy.com/login%EF%BC%8CBody">https://secure.mozy.com/login，Body</a> 的数据包含 authenticity_token ，用户名和密码，从而实现了登录。</li>
<li>访问 <a href="https://secure.mozy.com/%EF%BC%8C%E5%8F%AF%E4%BB%A5%E7%9C%8B%E5%88%B0%E5%B7%B1%E7%BB%8F%E6%98%AF%E7%99%BB%E5%BD%95%E7%9A%84%E7%8A%B6%E6%80%81%E3%80%82">https://secure.mozy.com/，可以看到己经是登录的状态。</a></li>
</ol>
<h1>22.5 实现 Mazy 登录</h1>
<p>具体的操作步骤如下 。</p>
<ol>
<li>启动 JMeter，新建一个线程组，添加 一个 Cookie 管理器 ，添加 一个“ 察看结果树”</li>
<li>在线程组下面新建一个 HTTP 请求，命名 为 loginPage</li>
</ol>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210113021151329.png" alt="image-20210113021151329"></p>
<ol start="3">
<li>保存脚本后运行，得到登录页面的 HTTP</li>
<li>使用 正则表达式工具 。 写一个获取 authenticity_token 的正则表达式 。正则表达式字符串是 authenticity_token ” type＝”hidden” value＝＂(*.?)”，</li>
<li>在 loginPage 这个 HTTP 请求下面添加一个正则表达式提取器，通过正则表达式提取器把 authenticity_token 的值提取出来，保存在变量 token 中。</li>
<li>在线程组下面新建一个 HTTP 请求，命名 为 login。</li>
</ol>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210113021246074.png" alt="image-20210113021246074"></p>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210113021256480.png" alt="image-20210113021256480"></p>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210113021308365.png" alt="image-20210113021308365"></p>
<ol start="7">
<li>在线程组下面新建一个 HTTP 请求，命名为 homePage。</li>
</ol>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210113021327540.png" alt="image-20210113021327540"></p>
<h1>22.6 简单的压力测试</h1>
<p>用 JMeter 很容易模拟压力测试。在线程组中，将线程数改为 5，代表同时有 5 个用户：循环次数是 10，代表每个用户循环 10 次。</p>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210113021358181.png" alt="image-20210113021358181"></p>
<p>在线程组中添加一个聚合报告，然后运行脚本，就能看到性能测试的结果。</p>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210113021416434.png" alt="image-20210113021416434"></p>
<p>我们通过聚合报告来分析性能测试的结果。</p>
<ol>
<li>Error% ：本次测试中出现错误请求的数量。正常情况下应该是 0.00%。否则就是功能出现了问题。也就是当大量用户访问的时候，造成了功能失败的问题，这个问题很严重。</li>
<li>Average ：平均响应时间，单位是 rns。对于一个 HTTP 请求来说，响应时间应该在 200rns 之内，但是图中 login 的平均响应时间是 5 492rns ，说明性能非常差。</li>
</ol>
<h1>参考</h1>
<p>《HTTP 抓包实战》</p>
]]></content>
      <categories>
        <category>《HTTP 抓包实战》</category>
      </categories>
      <tags>
        <tag>http</tag>
        <tag>抓包</tag>
      </tags>
  </entry>
  <entry>
    <title>19 遍历聚合对象中的元素 -- 迭代器模式</title>
    <url>/2020/01/11/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%89%BA%E6%9C%AF/19%20%E9%81%8D%E5%8E%86%E8%81%9A%E5%90%88%E5%AF%B9%E8%B1%A1%E4%B8%AD%E7%9A%84%E5%85%83%E7%B4%A0%20--%20%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>可以能够电视机看成一个存储电视频道的集合对象，通过遥控器可以对电视机中的电视频道几何进行操作，例如返回上一个频道、跳转到下一个频道或者跳转至指定的频道。遥控器为操作电视频道带来很大方便，用户并不需要知道这些频道到底如何存储在电视机中。</p>
<a id="more"></a>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20201204111019763.png" alt="image-20201204111019763"></p>
<p>在软件开发中，也存在大量类似电视机一样的类，它们可以存储多个成员对象（元素），这些类通常称为聚合类（Aggregate Classes），对应的对象称为聚合对象。为了更加方便地操作这些聚合对象，同时可以很灵活地为聚合对象增加不同的遍历方法，也需要类似电视机遥控器一样的角色，可以访问一个聚合对象中的元素但又不需要暴露它的内部结构。</p>
<p>通过如迭代器，客户端无需了解聚合对象的内部结构即可实现对聚合对象中成员的遍历，还可以根据需要很方便地增加新的遍历方式。</p>
<h1>19.1 销售管理系统中数据的遍历</h1>
<p>Sunny 发现经常需要对系统中的商品数据、客户数据等进行遍历，为了复用这些遍历代码，Sunny 公司开发人员设计了一个抽象的数据聚合类 AbstractObjectList，而将存储商品和客户等数据的类作为其子类。AbstractObjectList 类如图。</p>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20201204111104927.png" alt="image-20201204111104927"></p>
<p>List 类型的对象 objects 用于存储数据，AbstractObjectList 类的方法。</p>
<p>AbstractObjectList 方法说明</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>AbstractObjectList()</td>
<td>构造方法，用于给 objects 对象赋值</td>
</tr>
<tr>
<td>addObject()</td>
<td>增加元素</td>
</tr>
<tr>
<td>removeObject()</td>
<td>删除元素</td>
</tr>
<tr>
<td>getObjects()</td>
<td>获取所有元素</td>
</tr>
<tr>
<td>next()</td>
<td>移至下一个元素</td>
</tr>
<tr>
<td>isLast()</td>
<td>判断当前元素是否是最后一个元素</td>
</tr>
<tr>
<td>previous()</td>
<td>移至上一个元素</td>
</tr>
<tr>
<td>isFirst()</td>
<td>判断当前元素是否是第一个元素</td>
</tr>
<tr>
<td>getNextItem()</td>
<td>获取下一个元素</td>
</tr>
<tr>
<td>getPreviousItem()</td>
<td>获取上一个元素</td>
</tr>
</tbody>
</table>
<p>AbstractObjectList 类的子类 ProductList 和 CustomerList 分别用于存储商品数据和客户数据。</p>
<p>目前存在的问题：</p>
<ol>
<li>addObject()，removeObject() 等方法用于管理数据，而 next()、isLast()、previous()、isFirst() 等方法用于遍历数据。
<ul>
<li>导致聚合类的职责过重：既负责存储和管理数据，又负责遍历数据，违反单一职责原则</li>
</ul>
</li>
<li>如果将抽象聚合类声明为一个接口，则在这个接口中充斥着大量方法，不利于子类实现，违反了接口隔离原则</li>
<li>如果将所有的遍历操作都交给子类来实现，将导致子类代码庞大，而且必须暴露 AbstractObjectList 的内部存储细节，向子类公开自己的私有属性，否则子类无法实施对数据的遍历，这将破坏 AbstractObjectList 类的封装性</li>
</ol>
<p>如何解决上述问题：</p>
<ul>
<li>将聚合类中负责遍历数据的方法提取出来，封装到专门的类中，实现数据存储和数据遍历分离，无需暴露聚合类的内部属性即可对其进行操作</li>
</ul>
<h1>19.2 迭代器模式概述</h1>
<p>聚合对象拥有两个职责，一是存储数据；二是遍历数据。从依赖性来看，前者是聚合对象的基本职责；而后者近视可变化的，又是可分离的。因此，可以将遍历数据的行为从聚合对象中分离出来，封装在一个被称之为“迭代器”的对象中，由迭代器来提供遍历聚合对象内部数据的行为，可以简化聚合对象的设计。</p>
<blockquote>
<p>迭代器模式（Iterator Pattern）：提供一种方法来访问聚合对象，而不用暴露这个对象的内部表示，其别名为游标（Cursor）。</p>
<p>迭代器模式是这一种对象行为型模式。</p>
</blockquote>
<p>迭代器模式中包含聚合和迭代器两个层次结构。</p>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20201204132427390.png" alt="image-20201204132427390"></p>
<p>角色：</p>
<ol>
<li>Iterator（抽象迭代器）：定义了访问和遍历元素的接口，声明了用于遍历数据元素的方法
<ol>
<li>first()：获取第一个元素</li>
<li>next()：访问下一个元素</li>
<li>hasNext()：是否还有下一个元素</li>
<li>currentItem()：获取当前元素</li>
</ol>
</li>
<li>ConcreteIterator（具体迭代器）：实现了抽象迭代器接口，完成对聚合对象的遍历，同时在具体迭代器中通过游标来记录在聚合对象中所处的当前位置，在具体实现时，游标通常是一个表示位置的非负整数</li>
<li>Aggregate（抽象聚合类）：用于存储和管理元素对象，声明一个  createIterator() 方法用于创建一个迭代器对象，充当抽象迭代器工厂角色</li>
<li>ConcreteAggregate（具体聚合类）：实现了在抽象聚合类中声明的 createIterator() 方法，该方法返回一个与该具体聚合类对应的具体迭代器 ConcreteIterator 实例。</li>
</ol>
<p>在迭代器模式中，提供了一个外部的迭代器来对聚合对象进行访问和遍历，迭代器定义了一个访问该聚合元素的接口，并且可以跟踪当前遍历的元素，了解哪些元素已经遍历过而哪些没有。迭代器的引入，将使得对一个复杂聚合对象的操作变得简单。</p>
<p>在迭代器模式中应用了工厂方法模式，抽象迭代器对应于抽象产品角色，具体迭代器对应于具体产品角色，抽象聚合类对应于抽象工厂角色，具体聚合类对应于具体工厂角色。</p>
<p>在抽象迭代器中声明了用于遍历聚合对象中所存储元素的方法：</p>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20201204133648768.png" alt="image-20201204133648768"></p>
<p>在具体迭代器中将实现抽象迭代器声明的遍历数据的方法：</p>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20201204133706031.png" alt="image-20201204133706031"></p>
<p>【注意】</p>
<p>抽象迭代器接口的设计非常重要，一方面需要充分满足各种遍历操作的要求，尽量为各种遍历方法都提供声明，另一方面又不能包含太多方法，接口中方法太多将给子类的实现带来麻烦。因此，可以考虑使用抽象类来设计抽象迭代器，在抽象类中为每一个方法提供一个空的默认实现。如果需要在具体迭代器中为聚合对象增加全新的遍历操作，则必须修改抽象迭代器和具体迭代器的源代码，这将违反开闭原则。</p>
<p>聚合类用于存储数据并负责创建迭代器对象：</p>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20201204134451873.png" alt="image-20201204134451873"></p>
<p>具体聚合类作为抽象聚合类的子类，一方面负责存储数据，另一方面实现了在抽象聚合类中声明的工厂方法 createIterator()，用于返回一个与该具体聚合类对应的具体迭代器对象：</p>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20201204134519712.png" alt="image-20201204134519712"></p>
<p>【思考】如何理解迭代器模式中具体你聚合类与具体迭代器类之间存在的依赖关系和关联关系？</p>
<h1>19.3 完整解决方案</h1>
<p>重构后：</p>
<ul>
<li>AbstractObjectList：抽象聚合类</li>
<li>ProductList：具体聚合类</li>
<li>AbstractIterator：抽象迭代器</li>
<li>ProductIterator：具体迭代器</li>
</ul>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20201204183604643.png" alt="image-20201204183604643"></p>
<p>AbstractObjectList.cs</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">AbstractObjectList</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">protected</span> ArrayList Objects;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">AbstractObjectList</span>(<span class="params">ArrayList objects</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        Objects = objects;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Add</span>(<span class="params"><span class="built_in">object</span> obj</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        Objects.Add(obj);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Remove</span>(<span class="params"><span class="built_in">object</span> obj</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        Objects.Remove(obj);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList <span class="title">Get</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">return</span> Objects;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>IAbstractIterator.cs</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 抽象迭代器</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">interface</span> <span class="title">IAbstractIterator</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 移动到下一个元素</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Next</span>(<span class="params"></span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 判断是否为最后一个元素</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span><span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line">    <span class="function"><span class="built_in">bool</span> <span class="title">IsLast</span>(<span class="params"></span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 移动到上一个元素</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Previous</span>(<span class="params"></span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 第一个元素</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span><span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line">    <span class="function"><span class="built_in">bool</span> <span class="title">IsFirst</span>(<span class="params"></span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 获取下一个元素</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span><span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line">    <span class="function"><span class="built_in">object</span> <span class="title">GetNextItem</span>(<span class="params"></span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 获取上一个元素</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span><span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line">    <span class="function"><span class="built_in">object</span> <span class="title">GetPreviousItem</span>(<span class="params"></span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ProductIterator.cs</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">ProductIterator</span> : <span class="title">IAbstractIterator</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> ProductList _productList;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> ArrayList _products;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> _cursor1;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> _cursor2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ProductIterator</span>(<span class="params">ProductList productList</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        _productList = productList;</span><br><span class="line">        _products = productList.Get();</span><br><span class="line">        _cursor2 = _products.Count - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Next</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">if</span> (_cursor1 &lt; _products.Count)</span><br><span class="line">        &#123;</span><br><span class="line">            _cursor1++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">IsLast</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">return</span> _cursor1 == _products.Count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Previous</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">if</span> (_cursor2 &gt; <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            _cursor2--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">IsFirst</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">return</span> _cursor2 == <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">object</span> <span class="title">GetNextItem</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">return</span> _products[_cursor1];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">object</span> <span class="title">GetPreviousItem</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">return</span> _products[_cursor2];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ProductList.cs</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">ProductList</span> : <span class="title">AbstractObjectList</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ProductList</span>(<span class="params">ArrayList objects</span>) : <span class="title">base</span>(<span class="params">objects</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IAbstractIterator <span class="title">CreateIterator</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ProductIterator(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Program.cs</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">var</span> products = <span class="keyword">new</span> ArrayList()</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">&quot;倚天剑&quot;</span>,</span><br><span class="line">            <span class="string">&quot;屠龙刀&quot;</span>,</span><br><span class="line">            <span class="string">&quot;断肠草&quot;</span>,</span><br><span class="line">            <span class="string">&quot;葵花宝典&quot;</span>,</span><br><span class="line">            <span class="string">&quot;四十二章经&quot;</span></span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> list = <span class="keyword">new</span> ProductList(products);</span><br><span class="line">        <span class="keyword">var</span> iterator = list.CreateIterator();</span><br><span class="line"></span><br><span class="line">        Console.WriteLine(<span class="string">&quot;正向遍历&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> ((!iterator.IsLast()))</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(iterator.GetNextItem() + <span class="string">&quot;,&quot;</span>);</span><br><span class="line">            iterator.Next();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Console.WriteLine();</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;=================================&quot;</span>);</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;逆向遍历：&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!iterator.IsFirst())</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(iterator.GetPreviousItem() + <span class="string">&quot;,&quot;</span>);</span><br><span class="line">            iterator.Previous();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果需要增加一个新的具体聚合类，例如客户数据聚合类，并且需要为客户数据聚合类提供不同于商品数据聚合类的正向遍历和逆向遍历操作，只需要增加一个新的聚合子类和一个新的具体迭代器类即可，原有类库代码无需修改，符合开闭原则；如果需要为 ProductList 类更换一个迭代器，只需要增加一个新的具体迭代器类作为抽象迭代器类的子类，重新实现遍历方法，原有迭代器代码无需修改，从迭代器的角度来看，也符合开闭原则；但是如果要在迭代器中增加新的方法，则需要修改抽象迭代器源代码，将违背开闭原则。</p>
<h1>19.4 使用内部类实现迭代器</h1>
<p>具体迭代器类和具体聚合类之间存在双重关系，其中一个关系为关联关系，在具体迭代器中需要维持一个对具体聚合对象的引用，该关联关系的目的是访问存储在聚合对象中的数据，以便于迭代器能够对这些数据进行遍历操作。除了使用关联关系外，为了能够让迭代器可以访问到聚合对象中的数据，可以将迭代器类设计为聚合类的内部类。</p>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20201206165438386.png" alt="image-20201206165438386"></p>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20201206165450529.png" alt="image-20201206165450529"></p>
<p>无论使用哪种实现细节，客户端代码都是一样的，也就是说客户端无需关心具体迭代器对象的创建细节，只需要通过调用工厂方法 createIterator() 即可得到一个可用的迭代器对象，这也是使用工厂方法模式的好处，通过工厂来封装对象的创建过程，简化了客户端的调用</p>
<h1>19.5 JDK 内置迭代器</h1>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20201206165754987.png" alt="image-20201206165754987"></p>
<p>Collection 接口和 Iterator 接口充当了迭代器模式的抽象层</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>抽象聚合类</td>
<td>Collection 接口</td>
</tr>
<tr>
<td>抽象迭代器</td>
<td>Iterator 接口</td>
</tr>
<tr>
<td>具体聚合类</td>
<td>Collection 接口的子类</td>
</tr>
</tbody>
</table>
<p>【思考】</p>
<p>为什么使用 iterator() 方法创建的迭代器无法实现逆向遍历？</p>
<h1>19.6 迭代器模式总结</h1>
<p>通过引入迭代器可以将数据的遍历功能从聚合对象中分离出来，聚合对象只负责存储数据，遍历数据由迭代器来完成。</p>
<p>很多编程语言的类库已经实现了迭代器模式。</p>
<h2 id="主要优点">主要优点</h2>
<ol>
<li>支持以不同的方式遍历一个聚合对象，在同一个聚合对象上可以定义多种遍历方式。在迭代器模式中只需要用一个不同的迭代器来替换原有迭代器即可改变遍历算法，也可以自己定义迭代器的子类以支持新的遍历方式</li>
<li>迭代器简化了聚合类。由于引入了迭代器，在原有的聚合对象中不需要再自行提供数据遍历等方法，这样可以简化聚合类的设计</li>
<li>在迭代器模式中，由于引入了抽象层，增加新的聚合类和迭代器类都很方便，无需修改原有代码，满足开闭原则的要求</li>
</ol>
<h2 id="主要缺点">主要缺点</h2>
<ol>
<li>由于迭代器模式将存储数据和遍历数据的职责分离，增加新的聚合类需要对应增加新的迭代器类，累的个数成对增加，这在一定程度上增加了系统的复杂性</li>
<li>抽象迭代器的设计难度较大，需要充分考虑到系统将来的扩展。</li>
</ol>
<h2 id="适用场景">适用场景</h2>
<ol>
<li>访问一个聚合对象的内容而无需暴露它的内部表示。将聚合对象的访问与内部数据的存储分离，使用访问聚合对象时无须了解其内部实现细节</li>
<li>需要为一个聚合对象提供多种遍历方式</li>
<li>为遍历不同的聚合结构提供一个统一的接口，在改接口的实现类中为不同的聚合结构提供不同的遍历方式，而客户端可以一致性地操作该接口</li>
</ol>
<h1>参考</h1>
]]></content>
      <categories>
        <category>《设计模式的艺术：软件开发人员内功修炼之道》</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>迭代器</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>21 自动登录禅道和自动开 Bug</title>
    <url>/2020/01/09/HTTP%20%E6%8A%93%E5%8C%85%E5%AE%9E%E6%88%98/21%20%E8%87%AA%E5%8A%A8%E7%99%BB%E5%BD%95%E7%A6%85%E9%81%93%E5%92%8C%E8%87%AA%E5%8A%A8%E5%BC%80%20Bug/</url>
    <content><![CDATA[<p>“禅道”是一个国产的开源项目管理软件，支持需求管理、任务管理、缺陷管理和测试用例管理。本章将综合之前所学的知识，包括 HTTP 协议、Fiddler 抓包和JMeter 发包，来完成禅道系统的自动化测试 。</p>
<p>本章涉及自动化登录禅道、自动开 Bug、自动关 Bug，同时讲述 JMeter 中 HTTP Cookie 管理器和 HTTP 请求默认值的用法。</p>
<a id="more"></a>
<h1>21.1 HTTP Cookie 管理器</h1>
<p>前面的章节中解释过，HTTP 协议本身是无状态的，为了维持登录的状态，我们引入了 Cookie 机制 。</p>
<p>Cookie 的流程如下。</p>
<p>第一步，浏览器发送第一个 HTTP 请求给 Web 服务器 ，里面包含用户名和密码。Web 服务器验证用户名和密码后，把登录相关的 Cookie 发送给浏览器客户端。</p>
<p>第二步，浏览器客户端再一次访问的时候，会带上 Cookie 。 这样才处于登录状态 ，否则会被服务器跳转到登录页面。</p>
<p>现在用 JMeter 来模拟整个登录过程，那么我们 需要在第一步后 ，用正则表达式提取器把登录相关的 Cooki巳提取出 来 ，然后把登录的 Cookie 插入后续的 HTTP 请求中形成关联。</p>
<p>这里如果用正则表达式来做的话会稍显麻烦。</p>
<p>JMeter 中的 HTTP Cookie 管理器可以自动管理 Cookie 。 有了它，我们就不需要去处理 Cookie 了，HTTP Cookie 管理器会自动存储和发送 Cookie 。</p>
<p>如果 HTTP 响应中包含 Co okie ，那么 HTTP Cookie 管理器会自动保存这些 Cookie 。 用户再次访问该站点时，HTTP 请求会自动使用这些 Cookie 。一个线程组有自己存储 Cookie 的区域，并且一个钱程组只能添加一个 HTTP Cookie 管理器 。</p>
<p>选择线程组，用鼠标右键单击添加 -&gt; 配置元件 -&gt; 添加线程组，HTTP Cookie 管理器里面不需要修改任何字段。</p>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210113013757907.png" alt="image-20210113013757907"></p>
<h1>21.2 HTTP 请求默认值</h1>
<p>我们在 JMeter 里一般都会添加多个 HTTP 请求，这些 HTTP 请求的 HOST、协议和端口都是一样的。 我们可以添加一个 HTTP 请求默认值，相当于一个模板 。 在 HTTP 请求默认值中设置 HOST、协议、URL、端口等内容，这样后续的 HTTP 请求就会继承 HTTP 请求默认值中的内容。</p>
<h1>21.3 禅道介绍和部署</h1>
<p>禅道是一个开源的项目 管理系统，集产品管理、项目管理、Bug 管理、文档管理、组织管理和测试用例管理于一体，是一款功能完备的项目管理软件，完美地覆盖了项目管理的核心流程 。很多创业公司都使用禅道。部署禅道非常简单，强烈建议读者自行搭建一个禅道系统，大概 10 分钟就能搭建好。不想自己搭建的话就用我提供的禅道。</p>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210113013945483.png" alt="image-20210113013945483"></p>
<p>我部署的禅道地址是 <a href="http://tankxiao.vicp.io/zentao/%EF%BC%8C%E7%94%A8%E6%88%B7%E5%90%8D%E6%98%AF">http://tankxiao.vicp.io/zentao/，用户名是</a> book，密码是 password。</p>
<p>现在用 JMeter 来实现禅道系统的自动登录，新建一个 Bug ，把这个 Bug 修改为“己修复”，再把这个 Bug 修改为“己关闭”。</p>
<h1>21.4 禅道操作和抓包分析</h1>
<p>我们一边用浏览器来手动操作，一边用 Fiddler 抓包分析，一边用 JMeter 来实现 ，以此逐步实现整个流程的自动化。</p>
<h2 id="21-4-1-第-1-步，自动登录禅道">21.4.1 第 1 步，自动登录禅道</h2>
<p>具体的操作步骤如下。</p>
<ol>
<li>
<p>启动 Fiddler，启动过滤。过滤掉一些不相干的 HTTP 请求，能让我们快速找到我们需要的 HTTP 请求。</p>
<p>在 Fiddler 中的 Filter 选项卡中激活 Filter，并且在 Response Type and size 中选中“ Show only HTML ”。</p>
</li>
</ol>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210113014235045.png" alt="image-20210113014235045"></p>
<ol start="2">
<li>启动 Fiddler，打开浏览器，输入 <a href="http://tankxiao.vicp.io/zentao%EF%BC%8C%E7%84%B6%E5%90%8E%E8%BE%93%E5%85%A5%E7%94%A8%E6%88%B7%E5%90%8D%E5%92%8C%E5%AF%86%E7%A0%81%EF%BC%8C%E5%8D%95%E5%87%BB%E2%80%9C">http://tankxiao.vicp.io/zentao，然后输入用户名和密码，单击“</a> 登录 ” 。</li>
</ol>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210113014319527.png" alt="image-20210113014319527"></p>
<p>从抓包可以看到 ，登录用 的是 POST 方法，但是密码是加密后发送给服务器 的，Body 中的数据是 account=book&amp;password==5f4dcc3b5aa765d61d8327 deb882cf99。</p>
<ol start="3">
<li>
<p>确认密码是怎么被加密的 。 该密码估计是用 JavaScript 代码加密 的 。 我们可 以查一下 JavaScript 代码。打开浏览器的开发工具，查找 JS 代码。不出所料 ，我们发现了 一个叫 MD5 的 JS 文件。</p>
<p>为了 确定该密码是被 MD5 加密的，我们进行一 下测试 。打开 MD5 的在线网站 ，网址是 <a href="http://www.md5.cz/%EF%BC%8C%E7%8E%B0%E5%9C%A8%E5%8F%AF%E4%BB%A5%E7%A1%AE%E5%AE%9A%E5%AF%86%E7%A0%81%E6%98%AF%E7%94%A8">http://www.md5.cz/，现在可以确定密码是用</a> MD5 加密的 。</p>
</li>
</ol>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210113014520563.png" alt="image-20210113014520563"></p>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210113014534027.png" alt=""></p>
<p>如何实现这个密码的加密呢？有两种方法。</p>
<p>（1）第一种方法，先发送一个请求给 <a href="http://www.md5.cz">http://www.md5.cz</a>，在 HTTP 响应中，我们用正则表达式把加密后的密码提取出来。这个方法的缺点是：如果网站不可用了，我们的脚本就不能工作了。</p>
<p>（2）第二种方法，用 BeanShell 的方法，用 Java 代码来进行 MD5 加密，把一个 Java 的 jar 包引入进来 。</p>
<p>我们采用第一种方法加密。如果读者想采用第二种方法，可以参考上一章中 BeanShell 的用法。</p>
<ol start="4">
<li>启动 JMeter，新建一个线程组，新建一个用户自定义的变量。添加 2 个变量：一个叫 usemame，一个叫 password。</li>
</ol>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210113014757859.png" alt="image-20210113014757859"></p>
<ol start="5">
<li>添加一个 HTTP 请求，命名为 GetMd5</li>
</ol>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210113014821015.png" alt="image-20210113014821015"></p>
<ol start="6">
<li>在 GetMd5 HTTP 请求下面新建一个正则表达式提取器。</li>
</ol>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210113014853119.png" alt="image-20210113014853119"></p>
<ol start="7">
<li>选择线程组，添加一个 HTTP Cookie 管理器，用来自动管理 Cookie 。</li>
<li>选择线程组，添加一个 HTTP 请求默认值。</li>
</ol>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210113014927403.png" alt="image-20210113014927403"></p>
<ol start="9">
<li>
<p>选择线程组，添加一个 HTTP 请求，命名为 login，这个 HTTP 请求就是用来登录的。这是一个 POST 请求，URL 地址是 /zentao/user-login.html，Body<br>
的数据应该是 account={usemame}&amp;password=${password2｝</p>
</li>
<li>
<p>添加“ 察看结果树”，并且运行，保存脚本 。</p>
</li>
</ol>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210113015104899.png" alt="image-20210113015104899"></p>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210113015117093.png" alt="image-20210113015117093"></p>
<p>到这一步 ，我们的登录终于做好了，可以看到我们 的密码是用 MD5 加密后发送的。</p>
<h2 id="21-4-2-第-2-步，创建一个新的-Bug">21.4.2 第 2 步，创建一个新的 Bug</h2>
<p>具体操作步骤如下。</p>
<ol>
<li>继续在浏览器中操作，在禅道中单击“测试”，单击“ Bug ” ，在右边单击“新建一个 Bug ”，会弹出 一个 Bug 的表单。在表单中填好一些必填字段。</li>
</ol>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210113015224291.png" alt="image-20210113015224291"></p>
<ol start="2">
<li>单击保存，新建一个 Bug 的 HTTP 请求就被 Fiddler 抓到了</li>
</ol>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210113015242758.png" alt="image-20210113015242758"></p>
<p>我们用 JMeter 也模拟出 一个一模一样的 HTTP 请求</p>
<p>添加一个新的 HTTP 请求，命名为 CreateBug，路径和 Body 的数据我们都从 Fiddler 里面复制过来</p>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210113015310683.png" alt="image-20210113015310683"></p>
<p>在 CreateBug 中新建一个 HTTP 信息头管理器，把 Header 都从 Fiddler 中复制过来，记得一定要删除 Host 和 Cookie 这 2 个 Header</p>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210113015343562.png" alt="image-20210113015343562"></p>
<h2 id="21-4-3-第-3-步，找到刚刚新建-Bug-的-ID">21.4.3 第 3 步，找到刚刚新建 Bug 的 ID</h2>
<p>先在 JMeter 中把上一步添加的 CreateBug 请求禁用，以防止创建太多的 Bug。</p>
<p>要修改这个 Bug，我们需要知道刚才所创建的 Bug 的 ID 是多少 。</p>
<p>我们回到 Bug 列表的页面，可以看到，根据 Bug 的标题，可以从这个页面获取到 Bug 的 ID</p>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210113015424490.png" alt="image-20210113015424490"></p>
<p>获取 Bug 列表的 HTTP 请求用的是 GET 方法。在 JMeter 中，新建一个 HTTP 请求，将其命名为 GetBugList</p>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210113015448494.png" alt="image-20210113015448494"></p>
<p>在 GetBugList 请求下面，添加一个正则表达式用于提取 Bug 的 ID。通过正则表达式，我们可以从 GetBugList 的 HTTP 响应中把 Bug 的值提取出来，存到变量 bugid 中 。</p>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210113015510167.png" alt="image-20210113015510167"></p>
<h2 id="21-4-4-第-4-步，修改-Bug-状态为“己解决”">21.4.4 第 4 步，修改 Bug 状态为“己解决”</h2>
<p>在浏览器中把 Bug 的状态修改为“己解决”。</p>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210113015550612.png" alt="image-20210113015550612"></p>
<p>Fiddler 抓包。</p>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210113015609841.png" alt="image-20210113015609841"></p>
<p>在 JMeter 中新建一个 HTTP 请求，命名为 EditBug。按照上面抓到的包，把 URL 和 body 数据都填好。注意 Bug 的 ID 是动态变化的，<br>
URL 中我们需要使用 ${bugid｝ 。</p>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210113015636642.png" alt="image-20210113015636642"></p>
<p>在 EditBug 这个 HTTP 请求下面新建一个 HTTP 信息头管理器，从 Fiddler 中把 Header 复制过来，粘贴到 HTTP 信息头管理器中。记得一定要删除 Host 和 Cookie 这 2 个 Header。</p>
<h2 id="21-4-5-第-5-步，关闭-Bug">21.4.5 第 5 步，关闭 Bug</h2>
<p>同样的道理，在浏览器上操作，把 Bug 关闭，Fiddler 抓包，然后用 JMeter 实现 。</p>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210113015737095.png" alt="image-20210113015737095"></p>
<h2 id="21-4-6-总结">21.4.6 总结</h2>
<p>整个流程就做完 了，我们可以用 JMeter 实现禅道的自动登录，自动开 Bug，自动修改 Bug 的状态并关闭 Bug 。</p>
<p>同样的道理，我们可以用此方法做接口的自动化测试。除了 JMeter 之外，还可以使用 Postman 来完成 。</p>
<h1>参考</h1>
<p>《HTTP 抓包实战》</p>
]]></content>
      <categories>
        <category>《HTTP 抓包实战》</category>
      </categories>
      <tags>
        <tag>http</tag>
        <tag>抓包</tag>
      </tags>
  </entry>
  <entry>
    <title>03 HTTP 协议请求方法和状态码</title>
    <url>/2020/01/09/HTTP%20%E6%8A%93%E5%8C%85%E5%AE%9E%E6%88%98/03%20HTTP%20%E5%8D%8F%E8%AE%AE%E8%AF%B7%E6%B1%82%E6%96%B9%E6%B3%95%E5%92%8C%E7%8A%B6%E6%80%81%E7%A0%81/</url>
    <content><![CDATA[<p>HTTP 请求方法、状态码和首部(Header）是互相配合、一起工作的。浏览器客户端通过 HTTP 方法告诉服务器要执行什么动作，服务器通过状态码来告诉浏览器客户端动作是否执行成功。</p>
<a id="more"></a>
<h1>3.1 URL 详解</h1>
<p>URL 的全称是 Uniform Resource Locator，中 文译名为“统一资源定位符”，用于完整地描述 Internet 上某一处资源的地址。</p>
<p>Internet 上的每个网页都有一个标识，一般称之为 URL 地址，或者 Web 地址，俗称“网址”。URL 地址可以是本地磁盘，也可以是局域网上的某一台计算机，更多的是 Internet 上的站点 。</p>
<p>URI 的全称是 Uniform Resource Identifier，中文译名为“统一资源标识符“用来唯一地标识一个资源。而 URL 是一种具体的 URI 。</p>
<p>我们可以简单地把 URI 和 URL 看作同一个东西 。</p>
<h2 id="3-1-1-URL-格式">3.1.1 URL 格式</h2>
<p>URL 的基本格式如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">schema:&#x2F;&#x2F;host[:port#]&#x2F;path&#x2F;...&#x2F;[?query-string][#anchor]</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th></th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>schema</td>
<td>指定低层使用的协议（例如 ：http, https, ftp)</td>
</tr>
<tr>
<td>host</td>
<td>HTTP 服务器的 IP 地址或者域名</td>
</tr>
<tr>
<td>port#</td>
<td>HTTP 服务器的默认端口是 80，这种情况下端口号可以省略。如果使用了别的端口，则必须指明，例如  <a href="http://www.cnblogs.com:8080/">http://www.cnblogs.com:8080/</a></td>
</tr>
<tr>
<td>path</td>
<td>访问资源的路径</td>
</tr>
<tr>
<td>query-string</td>
<td>发送给 http 服务器的数据</td>
</tr>
<tr>
<td>anchor</td>
<td>锚</td>
</tr>
</tbody>
</table>
<p>URL 的一个例子如下 ：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;www.mywebsite.com&#x2F;liqingwen&#x2F;test&#x2F;test.aspx?narne&#x3D;sviergn&amp;x&#x3D;true#stuff</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th></th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>Schema（协议）</td>
<td>http</td>
</tr>
<tr>
<td>host （域名）</td>
<td><a href="http://www.mywebsite.com">www.mywebsite.com</a></td>
</tr>
<tr>
<td>path（资源的路径）</td>
<td>/liqingwen/test/test.aspx</td>
</tr>
<tr>
<td>Query String（参数）</td>
<td>name=sviergn&amp;x=true</td>
</tr>
<tr>
<td>Anchor（锚）</td>
<td>stuff</td>
</tr>
</tbody>
</table>
<h1>3.1.2 URL 中的锚点</h1>
<p>锚点（Anchor）是一种超链接，只是它是页面内部的超链接。</p>
<p>假如有一个网页很长，而且里面的内容可以分为 N 个部分。这样的话，我们就可以在网页的顶部设置一些锚点，以便浏览者单击相应的锚点，快速到达本页内相应的位置，而不必在一个很长的网页里自行寻找。</p>
<p>锚点在 URL 的最右边，前面有一个字符“#”。</p>
<p>比如下面的 #source：<a href="http://www.cnblogs.com/liqingwen/p/7087990.html#source">http://www.cnblogs.com/liqingwen/p/7087990.html#source</a></p>
<h1>3.2 HTTP 请求方法</h1>
<p>HTTP 协议中定义了几种不同的请求命令，这些命令叫作 HTTP 方法 CHTTP Method）。每个 HTTP 请求报文中都包含一个方法，这个方法会告诉服务器要执行什么动作，如是要获取一个 Web 页面还是要删除一个文件。</p>
<p>HTTP 协议定义了很多与服务器交互的方法，最基本的有 5 种， 分别是 GET 、 HEAD 、POST 、PUT 、DELETE 。一个 URL 地址用于描述一个网络上的资源，而 HTTP 中的 GET、POST、PUT、DELETE 就对应着对这个资源的查、改、增、删 4 个操作。最常见的是 GET 和 POST 。GET 一般用于获取／查询资源信息，而 POST 一般用于更新资源信息。</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>GET</td>
<td>请求指定的页面信息并返回实体主体</td>
</tr>
<tr>
<td>HEAD</td>
<td>类似于GET请求,只不过返回的响应中没有具体的内容,用于获取报头</td>
</tr>
<tr>
<td>POST</td>
<td>向指定资源提交数椐进行处理请求(例如提交表单或者上传文件),数据被包 含在请求体中。POST请求可能会导致新的资源的建立和/或对已有资源的修改</td>
</tr>
<tr>
<td>PUT</td>
<td>从客户端向服务器传送的数据取代指定文档的内容</td>
</tr>
<tr>
<td>DELETE</td>
<td>请求服务器除指定的页面</td>
</tr>
</tbody>
</table>
<h1>3.2.1 GET 方法</h1>
<p>GET 是最常见的方法，用于获取资源，常用于向服务器查询某些信息。</p>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210102180234441.png" alt="image-20210102180234441"></p>
<p>启动 Fiddler，打开浏览器，输入 <a href="http://www.669.icu">http://www.669.icu</a>。从 Fiddler 中可以看到浏览器发出的是 GET 方法。</p>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210116150942966.png" alt="image-20210116150942966"></p>
<p>打开网页一般都是用 GET 方法，因为要从 Web 服务器获取信息。</p>
<h2 id="3-2-2-带参数的-GET-方法">3.2.2 带参数的 GET 方法</h2>
<p>浏览器也可以在 GET 方法中把数据传给服务器，数据放在 URL 的问号（？）后面 。</p>
<p>将查询字符串参数追加到 URL 末尾，以便将信息发送给服务器。这种方式叫查询字符串，或者叫 Query String。</p>
<p>百度中某搜索 URL 如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https:&#x2F;&#x2F;www.baidu.com&#x2F;s?ie&#x3D;utf-8&amp;f&#x3D;3&amp;rsv_bp&#x3D;1&amp;rsv_idx&#x3D;1&amp;tn&#x3D;baidu&amp;wd&#x3D;%E4%BD%A0%E5%A5%BD&amp;fenlei&#x3D;256&amp;rsv_pq&#x3D;8187eb1f001397cd&amp;rsv_t&#x3D;3f8e8T5zasKgSnEB9un5%2FDUp%2F1Z5B9z%2BvLILeBJCEeAJv5l%2FMUpFF%2B5AIT4&amp;rqlang&#x3D;cn&amp;rsv_enter&#x3D;1&amp;rsv_dl&#x3D;ts_0&amp;rsv_sug3&#x3D;6&amp;rsv_sug1&#x3D;4&amp;rsv_sug7&#x3D;100&amp;rsv_sug2&#x3D;0&amp;rsv_btype&#x3D;i&amp;prefixsug&#x3D;nih&amp;rsp&#x3D;0&amp;inputT&#x3D;5314&amp;rsv_sug4&#x3D;5315</span><br></pre></td></tr></table></figure>
<p>查询字符串以“名=值”这样的形式出现，多个名值之间用字符“＆＂隔开。</p>
<p>在 Fiddler 中，使用 WebForms 选项卡可以更清楚地看到 GET 方法中的查询字符串参数。</p>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210116150020346.png" alt="image-20210116150020346"></p>
<h2 id="3-2-3-POST-方法">3.2.3 POST 方法</h2>
<p>POST 方法通常用来把表单中填好的数据发送给服务器 。</p>
<p>启动 Fiddler，打开浏览器，输入 <a href="http://www.669.icu/posttest%EF%BC%8C%E8%BE%93%E5%85%A5%E7%94%A8%E6%88%B7%E5%90%8D%E5%92%8C%E5%AF%86%E7%A0%81">http://www.669.icu/posttest，输入用户名和密码</a> ， 然后单击登录。</p>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210102180949261.png" alt="image-20210102180949261"></p>
<p>我们可以清晰地看到浏览器发出的是 POST 方法，该方法把用户名和密码的信息发送给了服务器。</p>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210102181018330.png" alt="image-20210102181018330"></p>
<p>使用 WebForms Tab 可以更清楚地看到 Body 主体里面的内容。</p>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210102181056888.png" alt="image-20210102181056888"></p>
<h2 id="3-2-4-GET-和-POST-方法的区别">3.2.4 GET 和 POST 方法的区别</h2>
<p>GET 和 POST 的区别主要表现在如下方面：</p>
<ul>
<li>GET 提交的数据会放在 URL 之后，以问号（？）分割 URL 和传输数据 ，参数之间以＆相 连 ，如 EditPosts.aspx?name=testl&amp;id=123456。POST 方法是把提交的数据放在 HTTP 包的 Body 中</li>
<li>GET 提交 的数据大小有限制（因为浏览器对 URL 的长度有限制），而 POST 方法提交的数据大小没有限制</li>
<li>GET 方式需要使用 <code>Request.QueryString</code> 来取得变量的值 ，而 POST 方法通过 <code>Request.Form</code> 来获取变量的值</li>
<li>GET 方式提交数据会带来安全问题，比如一个登录页面通过 GET 方式提交数据时，用户名和密码将出现在 URL 上 ，如果页面可以被缓存或者其他人可以访问这台机器，就可以从历史记录获得该用户的账号和密码。</li>
</ul>
<h1>3.3 HTTP 状态码</h1>
<h2 id="3-3-1-什么是-HTTP-状态码">3.3.1 什么是 HTTP 状态码</h2>
<p>每个 HTTP 响应报文都会携带一个状态码，用于告诉客户端请求是否成功。状态码是一个 3 位数字的代码。</p>
<p>HTTP 状态码存在于 HTTP 的响应报文中， 其作用 是 Web 服务器用来告诉客户端发生了什么事。</p>
<p>HTTP 响应报文中的第一行，由 HTTP 协议版本号、状态码 、状态消息 3 部分组成。状态码用来告诉 HTTP 客户端 Web 服务器是否产生了预期的 HTTP 响应。</p>
<h1>3.3.2 状态码分类</h1>
<p>HTTP/1.1 中定义了 5 类状态码，状态码由 3 位数字组成 ，第一个数字定义了响应的类别。</p>
<p>HTTP 状态码被分为 5 大类 ， 支持如表 3-2 所示的状态码。随着协议的发展 ，HTTP 规范 中会定义更多的状态码 。</p>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210102181628213.png" alt="image-20210102181628213"></p>
<h2 id="3-3-3-常见的状态码">3.3.3 常见的状态码</h2>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210102181705286.png" alt="image-20210102181705286"></p>
<h2 id="3-3-4-200-OK">3.3.4 200 (OK)</h2>
<p>最常见的状态码就是成功响应状态码 200 了 ，它表明该请求被成功地完成 ，所请求的资源成功地发送回客户端 。</p>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210102181808010.png" alt="image-20210102181808010"></p>
<h2 id="3-3-5-204（No-Content，没有内容）">3.3.5 204（No Content，没有内容）</h2>
<p>返回的 HTTP 响应中只有一些 Header 和一个状态行，美有实体的主题内容（没有响应 Body）。</p>
<p>204 状态码的作用如下：</p>
<ol>
<li>在不获取资源的情况下了解资源的情况（比如判断其类型）</li>
<li>通过查看 HTTP 响应中的状态码看某个对象是否存在</li>
<li>通过查看 Header 测试资源是否被修改</li>
</ol>
<p>【实例】启动 Fiddler，启动浏览器访问 <a href="http://www.google.cn">http://www.google.cn</a>，会捕获到很多 204。</p>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210102182526077.png" alt="image-20210102182526077"></p>
<h2 id="3-3-6-206-Partial-Content，部分内容）">3.3.6 206 ( Partial Content，部分内容）</h2>
<p>206 状态码代表服务器已经成功处理了部分 GET 请求（只有发送 GET 方法的 HTTP请求 ，Web 服务器才可能返回 206 ） 。</p>
<p>206 的应用场景如下：</p>
<ol>
<li>
<p>FlashGet、迅雷或者 HTTP 下载工具都是使用 206 状态码来实现断点续传的</p>
</li>
<li>
<p>将一个大文档分解为多个下载段同 时下载，比如在线看视频。</p>
</li>
</ol>
<p>实例 ：如图 3-9 所示，一些流媒体技术， 比如在线视频可以边看边下载，就是使用 206 状态码来实现的。</p>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210102182714532.png" alt="image-20210102182714532"></p>
<p>启动 Fiddler，然后用浏览器打开“搜狐视频中的绿箭侠” <a href="http://tv.sohu.com/20121011/n354681393.shtml%EF%BC%8C%E4%BC%9A%E5%8F%91%E7%8E%B0">http://tv.sohu.com/20121011/n354681393.shtml，会发现</a> Fiddler 中就能看到一堆的 206。</p>
<ol>
<li>浏览器发送一个 GET 方法的 HTTP 请求，Header 中包含 Range: bytes=5303296-5336063 （意思就是请求得到 5303296～ 5336063 之间的数据〉</li>
<li>Web 服务器返回一个 206 的 HTTP 响应。Header 中包含 Content-Range: bytes 5303296-5336063/12129376 （表明这次返回的内容范围）</li>
</ol>
<h2 id="3-3-7-301-Moved-Permanently">3.3.7 301 (Moved Permanently)</h2>
<p>服务器返回 301 的时候，表示请求的网页己经永久性地转移到另一个地址。</p>
<p>在如下情况下需要用到 301。</p>
<ol>
<li>防止用户输错域名。比如 Google 担心用户输错域名 ，就把其他类似的域名买下来，比如 <a href="http://www.goOgle.com">www.goOgle.com</a> ，然后重定向到 <a href="http://www.google.com">www.google.com</a></li>
<li>网站更换域名 。一些网站壮大后 ，会换个更好的域名。比如京东以前的域名是 <a href="http://www.360buy.com">www.360buy.com</a>，现在的域名是 <a href="http://www.jd.com">www.jd.com</a></li>
<li>有多个权重不错的域名，需要把所有的权重都传递到新域名上，这就需要 301 重定向了。如果不设置 301，多个域名绑定在一个主机头上，会被搜索引擎认为是两个相同的站点，不利于网站的排名 。 绑定的域名越多，内 容重复度也就越高，排名越低 。</li>
</ol>
<p>【实例】查看京东的老域名跳转到新域名：</p>
<p>启动 Fiddler ，在浏览器中输入 <a href="http://www.360buy.com">http://www.360buy.com</a>。</p>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210102183723426.png" alt="image-20210102183723426"></p>
<ol>
<li>浏览器发送请求访问 <a href="http://www.360buy.com">www.360buy.com</a>，服务器返回 301 ，并且 Location 是 <a href="http://www.jd.com">www.jd.com</a></li>
<li>浏览器会读取 Location 中的 URL，自动发送一个新的 HTTP？请求去访问 <a href="http://www.jd.com">www.jd.com</a></li>
</ol>
<h2 id="3-3-8-302-Found">3.3.8 302 ( Found )</h2>
<p>当我们访问 一个 URL 的时候，服务器要我们访问另 一个资源 ，这时候浏览器会继续发一个 HTTP ，请求访 问 新的资源 。</p>
<p>【实例】在未登录状态下，直接访问需要登录才能访问的页面，会被服务器返回 302 ，跳转到登录页面 。 具体操作步骤如下。</p>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210102185851371.png" alt="image-20210102185851371"></p>
<ol>
<li>
<p>启动 Fiddler，打开浏览器，直接在地址栏中输入 <a href="https://i.cnblogs.com/">https://i.cnblogs.com/</a></p>
</li>
<li>
<p>在 Fiddler 中可以看到服务器返 回 302 ，井且 Location=/user/signin?ReturnUrl=%2f（告诉客户端，新的资源在这里）</p>
</li>
<li>
<p>浏览器会自动再发送一个新的 HTTP 请求一一去访问 <a href="https://i.cnblogs.com/user/signin?ReturnUrl=%2f">https://i.cnblogs.com/user/signin?ReturnUrl=%2F</a></p>
</li>
</ol>
<h2 id="3-3-9-301-和-302-的区别">3.3.9 301 和 302 的区别</h2>
<p>状态码 301 和 302 在语法上是一模一样的，都是在 Location 中返回新的 URL 。</p>
<p>区别在于：</p>
<ul>
<li>301 表示旧地址的资源己经被永久地移除了（这个资源不可访问了），搜索引擎会把权重算到新地址；</li>
<li>302 表示 旧地址的资源还在（仍然可以访问），这个重定向只是临时地从旧地址跳转到新地址，搜索引擎会把权重算到旧地址。</li>
</ul>
<h2 id="3-3-10-304-Not-Modified">3.3.10 304 (Not Modified)</h2>
<p>304 状态码代表上次的文档己经被缓存了，还可以继续使用。</p>
<p>例如打开博客园首页，会发现很多 HTTP 响应的状态码都是 304 ，如图所示 。304 的响应是没有 Body 的 。</p>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210102190301505.png" alt="image-20210102190301505"></p>
<p>如果你不想使用本地缓存，可以用【Ctrl+F5】组合键强制刷新页面。</p>
<h2 id="3-3-11-400-Bad-Request">3.3.11 400 (Bad Request)</h2>
<p>状态码 400 表示客户端请求有语法错误，发送的 HTTP 请求中的数据有错误（如表单有错误、Cookie 有错误）。不能被服务器所理解。</p>
<p>【实例】快递查询接口，如果参数不对 ，服务器会返回 400 状态码 。</p>
<p>打开 Fiddler ，在浏览器中输入 <a href="http://www.kuaidi100.com/query?type=xxx%E3%80%82">http://www.kuaidi100.com/query?type=xxx。</a></p>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210102190550135.png" alt="image-20210102190550135"></p>
<h2 id="3-3-12-401（Unauthorized">3.3.12 401（Unauthorized)</h2>
<p>状态码 401 是指未授权错误。有些网页采用的是 HTTP 基本认证（Basic Authentication），需要在 HTTP 请求中带上 Authorization Header，否则服务器会返回状态码 401。</p>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210102190704480.png" alt="image-20210102190704480"></p>
<h2 id="3-3-13-403-Forbidden">3.3.13 403 (Forbidden)</h2>
<p>403 状态码表示 Web 客户端发送的请求被 Web 服务器拒绝了。如果服务器想说明为什么拒绝请求，可以在 Bo dy 中描述原因。但这个状态码通常表示服务器不想说明拒绝原因。</p>
<p>访问 URL:<a href="http://t2.baidu.com/it/u=1791561788,200960144&amp;fm=0&amp;gp=0.jpg%EF%BC%8C%E4%BC%9A%E8%A2%AB%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%8B%92%E7%BB%9D%EF%BC%8C%E5%B9%B6%E4%B8%94%E8%BF%94%E5%9B%9E">http://t2.baidu.com/it/u=1791561788,200960144&amp;fm=0&amp;gp=0.jpg，会被服务器拒绝，并且返回</a> 403 状态码。</p>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210102190914993.png" alt="image-20210102190914993"></p>
<h2 id="3-3-14-404-Not-Found">3.3.14 404 ( Not Found )</h2>
<p>当你访问一个 URL ，这个 URL 的域名是正确的，但是资源不存在，服务器就会返回 404 状态码，告诉浏览器资源不存在（意味着输错了 URL）。</p>
<p>启动 F iddler，输入 <a href="http://www.cnblogs/tankxiao/p/888.html%EF%BC%88888.htrnl">http://www.cnblogs/tankxiao/p/888.html（888.htrnl</a> 这个文件在服务器上不存在〉。</p>
<p>如图所示，我们可以看到 Web 服务器会返回 404 状态码，这个 404 页面是可以自定义的。</p>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210102191123002.png" alt="image-20210102191123002"></p>
<h2 id="3-3-15-500-Internal-Server-Error">3.3.15 500 (Internal Server Error)</h2>
<p>状态码 500 代表服务器内部错误。出现错误的原因有很多，比如代码的错误、数据库连接语句出错、程序内部抛出异常、空指针错误等 。</p>
<p>当数据库连接不成功的时候，服务器返回 500 状态码 。</p>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210102191227974.png" alt="image-20210102191227974"></p>
<h2 id="3-3-16-503（Server-Unavailable）">3.3.16 503（Server Unavailable）</h2>
<p>状态码 503 表示服务器暂时不可用 。由于服务器维护或者过载，服务器当前无法处理请求 ；这个状况是临时的，并且将在一段时间以后恢复。</p>
<p><img data-src="https://note-sh-1304201078.file.myqcloud.com/images/image-20210102191330535.png" alt="image-20210102191330535"></p>
<h1>参考</h1>
<ul>
<li>《HTTP 抓包实战》</li>
</ul>
]]></content>
      <categories>
        <category>《HTTP 抓包实战》</category>
      </categories>
      <tags>
        <tag>http</tag>
        <tag>抓包</tag>
      </tags>
  </entry>
  <entry>
    <title>LINQ 基础</title>
    <url>/2020/01/11/CSharp/LINQ%20%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h1>简介</h1>
<p><strong>LINQ</strong>：<strong>语言集成查询</strong>，是 <strong>L</strong>anguage <strong>IN</strong>tegrated <strong>Q</strong>uery 的缩写。</p>
<p><strong>集成查询</strong>：为查询跨各种数据源和格式的数据提供了一致的模型。</p>
<p><strong>语言集成查询</strong>：由于这种查询并没有创造新的语言而只是在现有的语言基础上来进行实现。</p>
<a id="more"></a>
<h1>基础知识</h1>
<h2 id="特点">特点</h2>
<ul>
<li>LINQ 主要用于对集合（含 IEnumerate、ICollection 等）进行操作</li>
<li>通过扩展方法达到目的</li>
</ul>
<h2 id="按功能划分">按功能划分</h2>
<ol>
<li>
<p>LINQ to Object：查询内存集合。</p>
</li>
<li>
<p>LINQ to Provider：查询自定义数据源。</p>
<p>XML、JSON 等都可以作为 Provider 对应的数据源，数据源对应的 LINQ 查询叫 LINQ to &lt;数据源&gt;。</p>
<p>比如：LINQ to XML。</p>
</li>
</ol>
<h2 id="按语法划分">按语法划分</h2>
<ol>
<li>SQL 风格</li>
<li>函数风格</li>
</ol>
<h3 id="SQL-风格">SQL 风格</h3>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> list = <span class="keyword">from</span> user <span class="keyword">in</span> users</span><br><span class="line">  <span class="keyword">where</span> user.Name.Contains(<span class="string">&quot;Wang&quot;</span>)</span><br><span class="line">  <span class="keyword">select</span> user.Id;</span><br></pre></td></tr></table></figure>
<h3 id="函数风格">函数风格</h3>
<p>效果同上。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> list = users</span><br><span class="line">  .Where(u =&gt; user.Name.Contains(<span class="string">&quot;Wang&quot;</span>))</span><br><span class="line">  .Select(u =&gt; u.id);</span><br></pre></td></tr></table></figure>
<h1>方法运用</h1>
<h2 id="First、Last-和-Single-等">First、Last 和 Single 等</h2>
<ul>
<li>
<p>First、FirstOrDefault、Last、LastOrDefault、Single 和 SingleOrDefault 是快速查询集合中的第一个或最后一个元素的方法</p>
</li>
<li>
<p>如果集合是空的，First、Last 和 Single 都会报错，这时可以使用 FirstOrDefault、LastOrDefault 和 SingleOrDefault</p>
</li>
<li>
<p>Single/SingleOrDefault 和其它方法的区别是，它限定查询结果只有一个元素，如果查询结果集合中包含多个元素时会报错</p>
</li>
</ul>
<h3 id="示例">示例</h3>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span>[] &#123; <span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span> &#125;.First(x =&gt; x.Equals(<span class="string">&quot;b&quot;</span>)); <span class="comment">// 返回 ”b“</span></span><br><span class="line"><span class="keyword">new</span>[] &#123; <span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span> &#125;.First(x =&gt; x.Equals(<span class="string">&quot;c&quot;</span>)); <span class="comment">// 抛出 InvalidOperationException 异常</span></span><br><span class="line"><span class="keyword">new</span>[] &#123; <span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span> &#125;.FirstOrDefault(x =&gt; x.Equals(<span class="string">&quot;c&quot;</span>)); <span class="comment">// 返回 null</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span>[] &#123; <span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span> &#125;.Single(x =&gt; x.Equals(<span class="string">&quot;b&quot;</span>)); <span class="comment">// 返回 ”b“</span></span><br><span class="line"><span class="keyword">new</span>[] &#123; <span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span> &#125;.Single(x =&gt; x.Equals(<span class="string">&quot;c&quot;</span>)); <span class="comment">// 抛出 InvalidOperationException 异常</span></span><br><span class="line"><span class="keyword">new</span>[] &#123; <span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span> &#125;.SingleOrDefault(x =&gt; x.Equals(<span class="string">&quot;c&quot;</span>)); <span class="comment">// 返回 null</span></span><br><span class="line"><span class="keyword">new</span>[] &#123; <span class="string">&quot;a&quot;</span>, <span class="string">&quot;a&quot;</span> &#125;.Single(); <span class="comment">// 抛出 InvalidOperationException 异常</span></span><br></pre></td></tr></table></figure>
<h3 id="备注">备注</h3>
<ul>
<li>如果要确保查询结果的唯一性（比如通过手机号查询用户），建议使用 Single/SingleOrDefaut</li>
<li>如果只是判断元素是否存在，使用 Any 比 FirstOrDefault 更高效</li>
<li>其它情况应尽量使用 First/FirstOrDefault</li>
</ul>
<h2 id="Except-取差集">Except 取差集</h2>
<p>取出集合中与另一个集合所有元素中不同的元素。</p>
<h3 id="示例-2">示例</h3>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span>[] first = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span> &#125;;</span><br><span class="line"><span class="built_in">int</span>[] second = &#123; <span class="number">0</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span> &#125;;</span><br><span class="line">IEnumerable&lt;<span class="built_in">int</span>&gt; result = first.Except(second);</span><br><span class="line"><span class="comment">// result = &#123; 1, 4 &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span>[] second = &#123; <span class="number">0</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span> &#125;;</span><br><span class="line"><span class="built_in">int</span>[] third = &#123; <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span> &#125;;</span><br><span class="line">IEnumerable&lt;<span class="built_in">int</span>&gt; result = third.Except(second);</span><br><span class="line"><span class="comment">// result = &#123; 1, 4 &#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="注意">注意</h3>
<ul>
<li>Except 方法会去除重复元素</li>
</ul>
<h2 id="SelectMany-集合降维">SelectMany 集合降维</h2>
<p>把多维集合降维，比如把二维的集合平铺成一个一维的集合。</p>
<h3 id="示例-3">示例</h3>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> collection = <span class="keyword">new</span> <span class="built_in">int</span>[][]</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">int</span>[] &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;,</span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">int</span>[] &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> result = collection.SelectMany(x =&gt; x);</span><br><span class="line"><span class="comment">// result = [1, 2, 3, 4, 5, 6]</span></span><br></pre></td></tr></table></figure>
<h3 id="示例-2-迪卡尔积运算">示例 2 - 迪卡尔积运算</h3>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> list1 = <span class="keyword">new</span> List&lt;<span class="built_in">string</span>&gt; &#123; <span class="string">&quot;a1&quot;</span>, <span class="string">&quot;a2&quot;</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> list2 = <span class="keyword">new</span> List&lt;<span class="built_in">string</span>&gt; &#123; <span class="string">&quot;b1&quot;</span>, <span class="string">&quot;b2&quot;</span>, <span class="string">&quot;b3&quot;</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> result = list1.SelectMany(x =&gt; list2.Select(y =&gt; <span class="string">$&quot;<span class="subst">&#123;x&#125;</span><span class="subst">&#123;y&#125;</span>&quot;</span>));</span><br><span class="line"><span class="comment">// result = [&quot;a1b1&quot;, &quot;a1b2&quot;, &quot;a1b3&quot;, &quot;a2b1&quot;, &quot;a2b2&quot;, &quot;a2b3&quot;]</span></span><br></pre></td></tr></table></figure>
<h2 id="Aggregate-聚合">Aggregate 聚合</h2>
<p>对一个集合依次执行类似累加器的操作，就像滚雪球一样把数据逐步聚集在一起。</p>
<h3 id="示例：累加">示例：累加</h3>
<p>从 1 加到 10。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span>[] numbers = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span> &#125;;</span><br><span class="line"><span class="built_in">int</span> sum = numbers.Aggregate((prevSum, current) =&gt; prevSum + current);</span><br><span class="line"><span class="comment">// sum = 55</span></span><br></pre></td></tr></table></figure>
<h3 id="示例：拼接字符串">示例：拼接字符串</h3>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span>[] stringList = &#123; <span class="string">&quot;Hello&quot;</span>, <span class="string">&quot;World&quot;</span>, <span class="string">&quot;!&quot;</span> &#125;;</span><br><span class="line"><span class="built_in">string</span> joinedString = stringList.Aggregate((prev, current) =&gt; prev + <span class="string">&quot; &quot;</span> + current);</span><br><span class="line"><span class="comment">// joinedString = &quot;Hello World !&quot;</span></span><br></pre></td></tr></table></figure>
<h2 id="Join-关联查询">Join 关联查询</h2>
<p>和 SQL 查询一样，LINQ 同样支持 Inner Join、Left Join、Right Join、Cross Join 和 Full Outer Join。</p>
<h3 id="示例-4">示例</h3>
<p>数据源：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> first = <span class="keyword">new</span> List&lt;<span class="built_in">string</span>&gt;() &#123; <span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>,<span class="string">&quot;c&quot;</span> &#125;; <span class="comment">// 左边</span></span><br><span class="line"><span class="keyword">var</span> second = <span class="keyword">new</span> List&lt;<span class="built_in">string</span>&gt;() &#123; <span class="string">&quot;a&quot;</span>, <span class="string">&quot;c&quot;</span>, <span class="string">&quot;d&quot;</span> &#125;; <span class="comment">// 右边</span></span><br></pre></td></tr></table></figure>
<h4 id="Inner-Join">Inner Join</h4>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> result = <span class="keyword">from</span> f <span class="keyword">in</span> first</span><br><span class="line">              <span class="keyword">join</span> s <span class="keyword">in</span> second <span class="keyword">on</span> f <span class="keyword">equals</span> s</span><br><span class="line">              <span class="keyword">select</span> <span class="keyword">new</span> &#123; f, s &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同使用扩展方法：</span></span><br><span class="line"><span class="keyword">var</span> result = first.Join(second,</span><br><span class="line">    f =&gt; f,</span><br><span class="line">    s =&gt; s,</span><br><span class="line">    (f, s) =&gt; <span class="keyword">new</span> &#123; f, s &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// result: &#123;&quot;a&quot;,&quot;a&quot;&#125;</span></span><br><span class="line"><span class="comment">//         &#123;&quot;c&quot;,&quot;c&quot;&#125;</span></span><br></pre></td></tr></table></figure>
<h4 id="Left-Join">Left Join</h4>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> result = <span class="keyword">from</span> f <span class="keyword">in</span> first</span><br><span class="line">            <span class="keyword">join</span> s <span class="keyword">in</span> second <span class="keyword">on</span> f <span class="keyword">equals</span> s <span class="keyword">into</span> temp</span><br><span class="line">            <span class="keyword">from</span> t <span class="keyword">in</span> temp.DefaultIfEmpty()</span><br><span class="line">            <span class="keyword">select</span> <span class="keyword">new</span> &#123; First = f, Second = t &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者：</span></span><br><span class="line"><span class="keyword">var</span> result = <span class="keyword">from</span> f <span class="keyword">in</span> first</span><br><span class="line">            <span class="keyword">from</span> s <span class="keyword">in</span> second.Where(x =&gt; x == f).DefaultIfEmpty()</span><br><span class="line">            <span class="keyword">select</span> <span class="keyword">new</span> &#123; First = f, Second = s &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同使用扩展方法：</span></span><br><span class="line"><span class="keyword">var</span> result = first.GroupJoin(second,</span><br><span class="line">        f =&gt; f,</span><br><span class="line">        s =&gt; s,</span><br><span class="line">        (f, s) =&gt; <span class="keyword">new</span> &#123; First = f, Second = s &#125;)</span><br><span class="line">    .SelectMany(temp =&gt; temp.Second.DefaultIfEmpty(),</span><br><span class="line">        (f, s) =&gt; <span class="keyword">new</span> &#123; First = f.First, Second = s &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// result: &#123;&quot;a&quot;,&quot;a&quot;&#125;</span></span><br><span class="line"><span class="comment">//         &#123;&quot;b&quot;, null&#125;</span></span><br><span class="line"><span class="comment">//         &#123;&quot;c&quot;,&quot;c&quot;&#125;</span></span><br></pre></td></tr></table></figure>
<h4 id="Right-Join">Right Join</h4>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> result = <span class="keyword">from</span> s <span class="keyword">in</span> second</span><br><span class="line">            <span class="keyword">join</span> f <span class="keyword">in</span> first <span class="keyword">on</span> s <span class="keyword">equals</span> f <span class="keyword">into</span> temp</span><br><span class="line">            <span class="keyword">from</span> t <span class="keyword">in</span> temp.DefaultIfEmpty()</span><br><span class="line">            <span class="keyword">select</span> <span class="keyword">new</span> &#123; First = t, Second = s &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 其它和 Left Join 类似</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// result: &#123;&quot;a&quot;,&quot;a&quot;&#125;</span></span><br><span class="line"><span class="comment">//         &#123;&quot;c&quot;,&quot;c&quot;&#125;</span></span><br><span class="line"><span class="comment">//         &#123;null,&quot;d&quot;&#125;</span></span><br></pre></td></tr></table></figure>
<h4 id="Cross-Join">Cross Join</h4>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> result = <span class="keyword">from</span> f <span class="keyword">in</span> first</span><br><span class="line">            <span class="keyword">from</span> s <span class="keyword">in</span> second</span><br><span class="line">            <span class="keyword">select</span> <span class="keyword">new</span> &#123; f, s &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// result: &#123;&quot;a&quot;,&quot;a&quot;&#125;</span></span><br><span class="line"><span class="comment">//         &#123;&quot;a&quot;,&quot;c&quot;&#125;</span></span><br><span class="line"><span class="comment">//         &#123;&quot;a&quot;,&quot;d&quot;&#125;</span></span><br><span class="line"><span class="comment">//         &#123;&quot;b&quot;,&quot;a&quot;&#125;</span></span><br><span class="line"><span class="comment">//         &#123;&quot;b&quot;,&quot;c&quot;&#125;</span></span><br><span class="line"><span class="comment">//         &#123;&quot;b&quot;,&quot;d&quot;&#125;</span></span><br><span class="line"><span class="comment">//         &#123;&quot;c&quot;,&quot;a&quot;&#125;</span></span><br><span class="line"><span class="comment">//         &#123;&quot;c&quot;,&quot;c&quot;&#125;</span></span><br><span class="line"><span class="comment">//         &#123;&quot;c&quot;,&quot;d&quot;&#125;</span></span><br></pre></td></tr></table></figure>
<h4 id="Full-Outer-Join">Full Outer Join</h4>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> leftJoin = <span class="keyword">from</span> f <span class="keyword">in</span> first</span><br><span class="line">            <span class="keyword">join</span> s <span class="keyword">in</span> second <span class="keyword">on</span> f <span class="keyword">equals</span> s <span class="keyword">into</span> temp</span><br><span class="line">            <span class="keyword">from</span> t <span class="keyword">in</span> temp.DefaultIfEmpty()</span><br><span class="line">            <span class="keyword">select</span> <span class="keyword">new</span> &#123; First = f, Second = t &#125;;</span><br><span class="line"><span class="keyword">var</span> rightJoin = <span class="keyword">from</span> s <span class="keyword">in</span> second</span><br><span class="line">            <span class="keyword">join</span> f <span class="keyword">in</span> first <span class="keyword">on</span> s <span class="keyword">equals</span> f <span class="keyword">into</span> temp</span><br><span class="line">            <span class="keyword">from</span> t <span class="keyword">in</span> temp.DefaultIfEmpty()</span><br><span class="line">            <span class="keyword">select</span> <span class="keyword">new</span> &#123; First = t, Second = s &#125;;</span><br><span class="line"><span class="keyword">var</span> fullOuterJoin = leftJoin.Union(rightJoin);</span><br></pre></td></tr></table></figure>
<h2 id="Skip-Take-分页">Skip &amp; Take 分页</h2>
<ul>
<li>
<p>Skip 扩展方法用来跳过从起始位置开始的指定数量的元素读取集合</p>
</li>
<li>
<p>Take 扩展方法用来从集合中只读取指定数量的元素</p>
</li>
</ul>
<h3 id="示例-5">示例</h3>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> values = <span class="keyword">new</span>[] &#123; <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> skipTwo = values.Skip(<span class="number">2</span>);  <span class="comment">// &#123; 3, 2, 1 &#125;</span></span><br><span class="line"><span class="keyword">var</span> takeThree = values.Take(<span class="number">3</span>);  <span class="comment">// &#123; 5, 4, 3 &#125;</span></span><br><span class="line"><span class="keyword">var</span> skipOneTakeTwo = values.Skip(<span class="number">1</span>).Take(<span class="number">2</span>); <span class="comment">// &#123; 4, 3 &#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="扩展-SkipWhile、TakeWhile">扩展 - SkipWhile、TakeWhile</h3>
<ul>
<li>SkipWhile 从起始位置开始忽略元素，直到遇到不符合条件的元素则停止忽略，往后就是要查询的结果</li>
<li>TakeWhile 从起始位置开始读取符合条件的元素，一旦遇到不符合条件的就停止读取，即使后面还有符合条件的也不再读取</li>
</ul>
<h4 id="示例-6">示例</h4>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// SkipWhile </span></span><br><span class="line"><span class="built_in">int</span>[] list = &#123; <span class="number">42</span>, <span class="number">42</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">42</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> result = list.SkipWhile(i =&gt; i == <span class="number">42</span>);</span><br><span class="line"><span class="comment">// result: 6, 6, 6, 42</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// TakeWhile </span></span><br><span class="line"><span class="built_in">int</span>[] list = &#123; <span class="number">1</span>, <span class="number">10</span>, <span class="number">40</span>, <span class="number">50</span>, <span class="number">44</span>, <span class="number">70</span>, <span class="number">4</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> result = list.TakeWhile(item =&gt; item &lt; <span class="number">50</span>).ToList();</span><br><span class="line"><span class="comment">// result = &#123; 1, 10, 40 &#125;</span></span><br></pre></td></tr></table></figure>
<h2 id="Zip-拉链">Zip 拉链</h2>
<p>操作的对象是两个集合，它就像拉链一样，根据位置将两个系列中的每个元素依次配对在一起。</p>
<h3 id="示例-7">示例</h3>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span>[] numbers = &#123; <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span> &#125;;</span><br><span class="line"><span class="built_in">string</span>[] words = &#123; <span class="string">&quot;three&quot;</span>, <span class="string">&quot;five&quot;</span>, <span class="string">&quot;seven&quot;</span>, <span class="string">&quot;ignored&quot;</span> &#125;;</span><br><span class="line">IEnumerable&lt;<span class="built_in">string</span>&gt; zip = numbers.Zip(words, (n, w) =&gt; n + <span class="string">&quot;=&quot;</span> + w);</span><br><span class="line"></span><br><span class="line"><span class="keyword">foreach</span> (<span class="built_in">string</span> s <span class="keyword">in</span> zip)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="comment">// 3=three</span></span><br><span class="line"><span class="comment">// 5=five</span></span><br><span class="line"><span class="comment">// 7=seven</span></span><br></pre></td></tr></table></figure>
<h2 id="OfType-和-Cast-类型过滤与转换">OfType 和 Cast 类型过滤与转换</h2>
<ul>
<li>OfType 用于筛选集合中指定类型的元素</li>
<li>Cast 可以把集合转换为指定类型</li>
</ul>
<h3 id="示例-8">示例</h3>
<p>数据源：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title">IFoo</span> &#123; &#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Foo</span> : <span class="title">IFoo</span> &#123; &#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Bar</span> : <span class="title">IFoo</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> item0 = <span class="keyword">new</span> Foo();</span><br><span class="line"><span class="keyword">var</span> item1 = <span class="keyword">new</span> Foo();</span><br><span class="line"><span class="keyword">var</span> item2 = <span class="keyword">new</span> Bar();</span><br><span class="line"><span class="keyword">var</span> item3 = <span class="keyword">new</span> Bar();</span><br><span class="line"><span class="keyword">var</span> collection = <span class="keyword">new</span> IFoo[] &#123; item0, item1, item2, item3 &#125;;</span><br></pre></td></tr></table></figure>
<h4 id="OfType-示例">OfType 示例</h4>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> foos = collection.OfType&lt;Foo&gt;(); <span class="comment">// result: item0, item1</span></span><br><span class="line"><span class="keyword">var</span> bars = collection.OfType&lt;Bar&gt;(); <span class="comment">// result: item2, item3</span></span><br><span class="line"><span class="keyword">var</span> foosAndBars = collection.OfType&lt;IFoo&gt;(); <span class="comment">// result: item0, item1, item2, item3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于使用 Where</span></span><br><span class="line"><span class="keyword">var</span> foos = collection.Where(item =&gt; item <span class="keyword">is</span> Foo); <span class="comment">// result: item0, item1</span></span><br><span class="line"><span class="keyword">var</span> bars = collection.Where(item =&gt; item <span class="keyword">is</span> Bar); <span class="comment">// result: item2, item3</span></span><br></pre></td></tr></table></figure>
<h4 id="Cast-示例">Cast 示例</h4>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> bars = collection.Cast&lt;Bar&gt;();  <span class="comment">// InvalidCastException 异常</span></span><br><span class="line"><span class="keyword">var</span> foos = collection.Cast&lt;Foo&gt;();  <span class="comment">// InvalidCastException 异常</span></span><br><span class="line"><span class="keyword">var</span> foosAndBars = collection.Cast&lt;IFoo&gt;();  <span class="comment">// OK</span></span><br></pre></td></tr></table></figure>
<h2 id="ToLookup-索引式查找">ToLookup 索引式查找</h2>
<p>可索引查找的数据结构，它是一个 ILookup 实例，所有元素根据指定的键进行分组并可以按键进行索引。</p>
<h3 id="示例-9">示例</h3>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span>[] array = &#123; <span class="string">&quot;one&quot;</span>, <span class="string">&quot;two&quot;</span>, <span class="string">&quot;three&quot;</span> &#125;;</span><br><span class="line"><span class="comment">// 根据元素字符串长度创建一个查找对象</span></span><br><span class="line"><span class="keyword">var</span> lookup = array.ToLookup(item =&gt; item.Length);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找字符串长度为 3 的元素</span></span><br><span class="line"><span class="keyword">var</span> result = lookup[<span class="number">3</span>];</span><br><span class="line"><span class="comment">// result: one,two</span></span><br></pre></td></tr></table></figure>
<h3 id="示例二">示例二</h3>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span>[] array = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span> &#125;;</span><br><span class="line"><span class="comment">// 创建一个奇偶查找（键为 0 和 1）</span></span><br><span class="line"><span class="keyword">var</span> lookup = array.ToLookup(item =&gt; item % <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找偶数</span></span><br><span class="line"><span class="keyword">var</span> even = lookup[<span class="number">0</span>];</span><br><span class="line"><span class="comment">// even: 2,4,6,8</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找奇数</span></span><br><span class="line"><span class="keyword">var</span> odd = lookup[<span class="number">1</span>];</span><br><span class="line"><span class="comment">// odd: 1,3,5,7</span></span><br></pre></td></tr></table></figure>
<h2 id="Distinct-去重">Distinct 去重</h2>
<p>去除重复项。</p>
<h3 id="示例-10">示例</h3>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span>[] array = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> distinct = array.Distinct();</span><br><span class="line"><span class="comment">// distinct = &#123; 1, 2, 3, 4, 5 &#125;</span></span><br></pre></td></tr></table></figure>
<h2 id="ToDictionary-字典转换">ToDictionary 字典转换</h2>
<p>把集合 <code>IEnumerable&lt;TElement&gt;</code> 转换为 <code>Dictionary&lt;TKey, TValue&gt;</code> 结构的字典，接收一个 <code>Func&lt;TSource, TKey&gt;</code> 参数用来返回每个元素指定的键与值。</p>
<h3 id="示例-11">示例</h3>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">IEnumerable&lt;User&gt; users = GetUsers();</span><br><span class="line">Dictionary&lt;<span class="built_in">int</span>, User&gt; usersById = users.ToDictionary(x =&gt; x.Id);</span><br></pre></td></tr></table></figure>
<h2 id="Range-和-Repeat">Range 和 Repeat</h2>
<p>用于生成简单的数字或字符串系列。</p>
<h3 id="示例-12">示例</h3>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 生成 1-100 的数字，即结果为 [1, 2, ..., 99, 100]</span></span><br><span class="line"><span class="keyword">var</span> range = Enumerable.Range(<span class="number">1</span>, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成三个重复的字符串“a”，即结果为 [&quot;a&quot;, &quot;a&quot;, &quot;a&quot;]</span></span><br><span class="line"><span class="keyword">var</span> repeatedValues = Enumerable.Repeat(<span class="string">&quot;a&quot;</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure>
<h2 id="Any-和-All">Any 和 All</h2>
<ul>
<li>Any 用来判断集合中是否存在任一一个元素符合条件</li>
<li>All 用来判断集合中是否所有元素符合条件</li>
</ul>
<h3 id="示例-13">示例</h3>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> numbers = <span class="keyword">new</span> <span class="built_in">int</span>[] &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line"><span class="built_in">bool</span> result = numbers.Any(); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">bool</span> result = numbers.Any(x =&gt; x == <span class="number">6</span>); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">bool</span> result = numbers.All(x =&gt; x &gt; <span class="number">0</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">bool</span> result = numbers.All(x =&gt; x &gt; <span class="number">1</span>); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<h2 id="Concat-和-Union">Concat 和 Union</h2>
<p>用来拼接两个集合。</p>
<ul>
<li>Concat：不会去除重复元素</li>
<li>Union：去除重复项</li>
</ul>
<h3 id="示例-14">示例</h3>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">List&lt;<span class="built_in">int</span>&gt; foo = newList&lt;<span class="built_in">int</span>&gt; &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;</span><br><span class="line">List&lt;<span class="built_in">int</span>&gt; bar = newList&lt;<span class="built_in">int</span>&gt; &#123; <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过 Enumerable 类的静态方法</span></span><br><span class="line"><span class="keyword">var</span> result = Enumerable.Concat(foo, bar).ToList(); <span class="comment">// 1,2,3,3,4,5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过扩展方法</span></span><br><span class="line"><span class="keyword">var</span> result = foo.Concat(bar).ToList(); <span class="comment">// 1,2,3,3,4,5</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> result = foo.Union(bar); <span class="comment">// 1,2,3,4,5</span></span><br></pre></td></tr></table></figure>
<h2 id="GroupBy-分组">GroupBy 分组</h2>
<p>对集合进行分组。</p>
<h3 id="示例-15">示例</h3>
<p>根据奇偶分组。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> list = <span class="keyword">new</span> List&lt;<span class="built_in">int</span>&gt;() &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> grouped = list.GroupBy(x =&gt; x % <span class="number">2</span> == <span class="number">0</span>);</span><br><span class="line"><span class="comment">// grouped: [1, 3, 5, 7, 9] 和 [2, 4, 6, 8]</span></span><br></pre></td></tr></table></figure>
<h2 id="DefaultIfEmpty-空替换">DefaultIfEmpty 空替换</h2>
<p>表示在没有查询到指定条件的元素时使用元素的默认值代替。</p>
<h3 id="示例-16">示例</h3>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> chars = <span class="keyword">new</span> List&lt;<span class="built_in">string</span>&gt;() &#123; <span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>, <span class="string">&quot;d&quot;</span> &#125;;</span><br><span class="line">chars.Where(s =&gt; s.Length &gt; <span class="number">1</span>).DefaultIfEmpty().First(); <span class="comment">// 返回 null</span></span><br><span class="line">chars.DefaultIfEmpty(<span class="string">&quot;N/A&quot;</span>).FirstOrDefault(); <span class="comment">// 返回 &quot;a&quot;</span></span><br><span class="line">chars.Where(s =&gt; s.Length &gt; <span class="number">1</span>).DefaultIfEmpty(<span class="string">&quot;N/A&quot;</span>).FirstOrDefault(); <span class="comment">// 返回 &quot;N/A&quot;</span></span><br></pre></td></tr></table></figure>
<h2 id="SequenceEqual-集合相等">SequenceEqual 集合相等</h2>
<p>用于比较集合系列各个相同位置的元素是否相等。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span>[] a = <span class="keyword">new</span> <span class="built_in">int</span>[] &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"><span class="built_in">int</span>[] b = <span class="keyword">new</span> <span class="built_in">int</span>[] &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"><span class="built_in">int</span>[] c = <span class="keyword">new</span> <span class="built_in">int</span>[] &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">bool</span> result1 = a.SequenceEqual(b); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">bool</span> result2 = a.SequenceEqual(c); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<h2 id="其它常用方法">其它常用方法</h2>
<ul>
<li>OrderBy（排序）</li>
<li>Sum（求和）</li>
<li>Count（计数）</li>
<li>Reverse（反转）</li>
<li>Where（筛选、过滤）</li>
</ul>
<h1>参考</h1>
<p><a href="https://www.cnblogs.com/willick/p/13586024.html">08：强大的LINQ</a></p>
]]></content>
      <categories>
        <category>C#</category>
      </categories>
      <tags>
        <tag>linq</tag>
        <tag>C#</tag>
      </tags>
  </entry>
</search>
